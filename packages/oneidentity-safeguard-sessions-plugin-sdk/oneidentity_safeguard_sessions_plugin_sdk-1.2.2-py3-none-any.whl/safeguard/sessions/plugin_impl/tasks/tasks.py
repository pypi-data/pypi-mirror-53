#
# Copyright (c) 2006-2019 Balabit
# All Rights Reserved.
#
from glob import glob
from invoke import call, task, Exit
import logging
from .manifest import Manifest
from .dummy_plugin import Plugin as DummyPlugin
from .aa_plugin_tester import AAPluginTester, ScenarioStep
import os
import sys
import re
import importlib.util
from shutil import copyfile, rmtree
from textwrap import dedent
from zipfile import ZipFile
from safeguard.sessions.plugin import __version__ as plugin_sdk_version, __sps_min_version__ as sps_min_version
from safeguard.sessions.plugin.data.aa_sample import scenarios, GatewayAndTargetUserDiffer


log = logging.getLogger(__name__)
BUILD_DIR = 'build'
VENV_DIR = os.path.join(BUILD_DIR, "venv")
DIST_DIR = 'dist'


DIST_PACKAGE_EXCLUDE_LIST = ("pip", "pkg-resources", "setuptools", "wheel")
DIST_ZIP_EXCLUDE_LIST = (
    os.path.join("pip", ".*"),
    os.path.join("wheel", ".*"),
    os.path.join("setuptools", ".*"),
    os.path.join("pkg_resources", ".*"),
    os.path.join(".*[.]dist-info", ".*"),
    os.path.join(".*[.]egg-info", ".*"),
    "easy_install.*",
)
DIST_EXTRA_FILES = ("MANIFEST", "CHANGELOG", "NEWS", "README", "README.md", "default.cfg", "LICENSE.txt")


@task
def check_manifest(c):
    manifest = Manifest.from_file()
    manifest.check_api_version(plugin_sdk_version)


@task
def check_default_cfg(c):
    if not os.path.exists("default.cfg"):
        log.warning("WARNING: Plugin should have a default.cfg file with configuration defaults and documentation.")


@task
def check_entry_point(c):
    manifest = Manifest.from_file()
    assert os.path.exists(manifest.entry_point), "MANIFEST entry_point file must exist"


@task(help={'dirname': 'Name of directory to check and create'})
def ensure_dir(c, dirname):
    if os.path.isdir(dirname):
        return
    log.info("Creating directory = {}".format(dirname))
    os.mkdir(dirname)


@task
def ensure_setup_py(c):
    if os.path.exists("setup.py"):
        return
    log.warning("Auto generating setup.py")
    manifest = Manifest.from_file()
    with open("setup.py", "w") as f:
        f.write(dedent("""
            # Auto generated by pluginv {func} task
            from setuptools import find_packages, setup
            setup(
                name="{name}".lower(),
                version="{version}",
                packages=find_packages(exclude=[
                    "*.tests",
                    "*.tests.*",
                    "tests.*",
                    "tests"
                ]),
                py_modules=["{module}"]
            )
       """).format(
            func=ensure_setup_py.__name__,
            name=manifest.name,
            version=manifest.version,
            module=calc_module_name(manifest.entry_point)))


@task
def ensure_conftest_py(c):
    if os.path.exists("conftest.py"):
        return
    log.warning("Auto generating conftest.py")
    with open("conftest.py", "w") as f:
        f.write(dedent("""
            # Auto generated by pluginv {func} task
            # Import common pytest fixtures
            from safeguard.sessions.plugin_impl.tasks.common_conftest import *  # noqa: F401,F403
        """).format(func=ensure_conftest_py.__name__))


def calc_module_name(entry_point):
    tokens = entry_point.split('.')
    if tokens[-1] == 'py':
        tokens = tokens[:-1]
    return '.'.join(tokens)


@task
def create_dist_virtualenv(c):
    create_virtualenv(c)
    pip_requirements = dist_pip_requirements(c)
    if pip_has_package_requirement(pip_requirements):
        pip_install_requirements(c, pip_requirements)
        generate_3rdparty_license_file(c)
    pip_install_plugin(c)


@task
def copy_dist_files(c):
    for name in DIST_EXTRA_FILES:
        if not os.path.exists(name):
            continue
        collect_dir = get_collect_dir()
        copyfile(name, os.path.join(collect_dir, name))


PREPARE_COLLECT_DIR_STEPS = [
    call(ensure_dir, dirname=BUILD_DIR),
    call(ensure_dir, dirname=DIST_DIR),
    check_manifest,
    check_entry_point,
    ensure_setup_py,
    create_dist_virtualenv,
    copy_dist_files,
    check_default_cfg,
]


@task(
    help='Build snapshot plugin ZIP distribution package',
    pre=PREPARE_COLLECT_DIR_STEPS,
)
def dist(c):
    manifest = Manifest.from_file(os.path.join(get_collect_dir(), "MANIFEST"))
    manifest.make_snapshot_version()
    manifest.write_file()
    create_zip_file(c, get_plugin_zip_filename(manifest))


@task(
    help='Build release plugin ZIP distribution package',
    pre=PREPARE_COLLECT_DIR_STEPS,
)
def release(c, suffix=None):
    manifest = Manifest.from_file(os.path.join(get_collect_dir(), "MANIFEST"))
    if suffix:
        manifest.add_version_suffix(suffix)
        manifest.write_file()
    create_zip_file(c, get_plugin_zip_filename(manifest))


@task(
    help={'name': 'Name of scenario',
          'list_scenarios': 'List scenario names',
          'config_file': 'Name of config file',
          'target_username': 'Username on the server',
          'gateway_username': 'Username on the gateway',
          'self_test': 'Run standalone self-test on dummy plugin'},
    pre=[check_manifest, check_entry_point],
)
def run_scenario(c, name=None, list_scenarios=False, config_file=None, target_username=None,
                 gateway_username=None, self_test=False):
    if list_scenarios:
        [print(n) for n in scenarios.keys()]
        raise Exit(code=0)

    config = ''
    if config_file:
        with open(config_file) as f:
            config = f.read()

    manifest = Manifest.from_file("MANIFEST")

    sys.path.append(os.getcwd())

    plugin_class = DummyPlugin if self_test else load_source('plugintotest', manifest.entry_point).Plugin
    scenarios_to_run = [name] if name else list(scenarios.keys())
    for scenario_name in scenarios_to_run:
        print('Running scenario: {}'.format(scenario_name))
        try:
            AAPluginTester.run_scenario(plugin_class, config, scenarios[scenario_name],
                                        target_username, gateway_username)
        except GatewayAndTargetUserDiffer:
            raise Exit('Gateway and target username should be the same for a scenario without gateway authentication')


def load_source(name, pathname):
    module_spec = importlib.util.spec_from_file_location(name, pathname)
    module = importlib.util.module_from_spec(module_spec)
    module_spec.loader.exec_module(module)
    return module


def dist_pip_requirements(c):
    result = c.run("pipenv lock --requirements")
    return remove_pipenv_comments(result.stdout)


def remove_pipenv_comments(text):
    return [line for line in text.splitlines() if not re.fullmatch(' ; .*', line)]


def pip_has_package_requirement(pip_requirements):
    # exclude pip parameters starting with - (dash) and empty lines
    return len([line for line in pip_requirements if re.fullmatch('[^-].+', line)]) > 0


def create_virtualenv(c):
    log.debug("Removing existing virtualenv {}".format(VENV_DIR))
    rmtree(VENV_DIR, ignore_errors=True)
    c.run("virtualenv -p python3.6 {path}".format(path=VENV_DIR))


def pip_install_requirements(c, requirements):
    c.run("{pip} install {reqs}".format(
        pip=pip_path(),
        reqs=' '.join(requirements)  # should quote for bash?
    ))


def pip_install_plugin(c):
    c.run("{pip} install .".format(pip=pip_path()))


def generate_3rdparty_license_file(c):
    pip_list_result = c.run("{pip} list".format(pip=pip_path()))
    package_lines = pip_list_result.stdout.splitlines()[2:]
    with open(
            os.path.join(get_venv_python_lib_dir(), 'site-packages', '3rdparty-licenses.txt'), 'w'
    ) as license_file:
        for line in package_lines:
            packagename = line.split()[0]
            if packagename in DIST_PACKAGE_EXCLUDE_LIST:
                continue
            show_result = c.run("{pip} show {pkg}".format(pip=pip_path(), pkg=packagename))
            show_lines = show_result.stdout.splitlines()
            relevant_lines = [line for line in show_lines if re.fullmatch('(Name|Home-page|License).*', line)]
            relevant_lines = relevant_lines + ['', '']  # visual separator
            license_file.write('\n'.join(relevant_lines))


def pip_path():
    return os.path.join(VENV_DIR, 'bin', 'pip')


def get_collect_dir():
    return os.path.join(get_venv_python_lib_dir(), 'site-packages')


def get_venv_python_lib_dir():
    result = glob(os.path.join(VENV_DIR, 'lib', 'python*'))[0]
    log.debug("Detected python lib dir = {}".format(result))
    return result


def create_zip_file(c, zipname):
    collect_dir = get_collect_dir()
    exclude_pattern = '|'.join(DIST_ZIP_EXCLUDE_LIST)
    zipname = os.path.join(DIST_DIR, zipname)
    log.warning("Creating ZIP file={}".format(zipname))
    log.debug("Creating ZIP file from dir={} and exclude={}".format(collect_dir, exclude_pattern))

    with ZipFile(zipname, 'w') as z:
        for (dirpath, dirnames, filenames) in os.walk(collect_dir):
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                shortname = fullname[len(collect_dir) + 1:]
                if re.fullmatch(exclude_pattern, shortname):
                    continue
                log.debug("Adding {}".format(fullname))
                z.write(fullname, shortname)


def get_plugin_zip_filename(manifest):
    return manifest.name + "-" + manifest.version + ".zip"


@task(
    help="Run Python pep standard checks"
)
def check_codingstandard(c):
    c.run("flake8 --max-line-length=120 --exclude='.git,__pycache__,./build/*' --show-source --format=pylint")


@task(
    help="Shorthand for check_codingstandard",
    pre=[check_codingstandard]
)
def check_cs(c):
    pass


@task(
    help=dedent("""
        Run tests in non-interactive mode. Equivalent to
        $ pytest --backend-service=replay
        or simply
        $ pytest
    """),
    pre=[ensure_conftest_py],
)
def run_tests(c):
    c.run("pytest")


@task(
    help=dedent("""
        Run tests in interactive mode, do not modify test data. Equivalent to
        $ pytest --backend-service=use --capture=sys
    """),
    pre=[ensure_conftest_py],
)
def run_interactive_tests(c):
    c.run("pytest --backend-service=use --capture=sys")


@task(
    help=dedent("""
        Run tests in interactive mode, save modified test data. Equivalent to
        $ pytest --backend-service=record --capture=sys
    """),
    pre=[ensure_conftest_py],
)
def run_recording_tests(c):
    c.run("pytest --backend-service=record --capture=sys")


@task(help="Print Plugin SDK version")
def version_sdk(c):
    print(plugin_sdk_version)


@task(help="Print SPS min version defined by Plugin SDK")
def version_sps(c):
    print(sps_min_version)
