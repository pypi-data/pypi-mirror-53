#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
TODO: Fix ordering of dicts
"""
import argparse
import csv
import hashlib
import io
import json
import requests
import sys

from typing import Optional


URL = 'https://raw.githubusercontent.com/certtools/malware_name_mapping/master/mapping.csv'
URL_MALPEDIA = 'https://raw.githubusercontent.com/certtools/malware_name_mapping/master/malpedia.csv'


def none_len(arg: Optional[list]):
    if arg:
        return len(arg)
    else:
        return 0


def generate_rule(expression: str, identifier: str, name=None):
    return {"rulename": name if name else "%s-%s" % (identifier,
                                                     hashlib.sha1(expression.encode()).hexdigest()[:10]),
            "if": {"classification.taxonomy": "malicious code",
                   "malware.name": expression
                   },
            "then": {"classification.identifier": identifier, }}


def download(url: str=URL, add_default=False, params=None, include_malpedia=False):
    download = requests.get(url)
    download.raise_for_status()
    rules = [generate_rule(*line[:2])
             for line in csv.reader(io.StringIO(download.text))
             if not line[0].startswith('#')]
    if include_malpedia:
        download = requests.get(URL_MALPEDIA)
        download.raise_for_status()
        rules.extend([generate_rule(*line[:2])
                      for line in csv.reader(io.StringIO(download.text))
                      if not line[0].startswith('#')])

    if add_default:
        rules.append(generate_rule(".*", "{msg[malware.name]}", name="default"))

    if params:
        rules.extend((generate_rule(rule[0][0], rule[1][0]) for rule in params))

    return json.dumps(rules, indent=4, separators=(',', ': '))


def create_parser():
    parser = argparse.ArgumentParser(
        prog='download_mapping',
        description='Downloads malware family mapping and converts it to modify syntax.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
You can specify additional rules to be added to the file by using:
-e "^some-expression$" -i "some-identifier"
and multiple ones:
-e "^some-expression$" -i "some-identifier" -e "^other-expression$" -i "other-identifier"
'''
    )

    parser.add_argument('filename', nargs='?',
                        help='The filename to write the converted mapping to. If not given, printed to stdout.')
    parser.add_argument('--url', '-u',
                        default=URL,
                        help='The URL to download the mapping from.')
    parser.add_argument('--add-default', '-d',
                        help='Add a default rule to use the malware name as identifier.',
                        const=True, action='store_const')
    parser.add_argument('--expression', '-e',
                        nargs=1, action='append',
                        help='Expression for an additional rule.',
                        default=[])
    parser.add_argument('--identifier', '-i',
                        nargs=1, action='append',
                        help='Identifier for an additional rule.',
                        default=[])
    parser.add_argument('-m', '--include-malpedia',
                        default=False, action='store_true',
                        help='Include malpedia data (CC BY-NC-SA 3.0), '
                             'see https://malpedia.caad.fkie.fraunhofer.de/usage/tos from %s'
                             '' % URL_MALPEDIA)
    return parser


def main(args):
    if none_len(args.expression) != none_len(args.identifier):
        print('Additional rules must always consist of an expression and an identifier. '
              'Got %d expressions and %d identifiers.' % (len(args.expression), len(args.identifier)),
              file=sys.stderr)
        sys.exit(1)
    rules = download(url=args.url, add_default=args.add_default,
                     params=zip(args.expression, args.identifier),
                     include_malpedia=args.include_malpedia)
    if args.filename:
        try:
            with open(args.filename, 'wt') as output:
                output.write(rules)
        except PermissionError:
            print('Could not write to file %r.' % args.filename, file=sys.stderr)
            sys.exit(1)
    else:
        return rules


if __name__ == '__main__':
    parser = create_parser()
    args = parser.parse_args()
    retval = main(args)
    if retval:
        print(retval)
