import json
from functools import partial
from typing import Tuple, Optional, Dict, Any

from flask import g, Flask
from flask import request
from flask_requests import get_token
from nezha import pyjwt
from nezha.func import check_argument
from nezha.pyjwt import is_valid


def verify_cache(cache: Optional[Any] = None) -> bool:
    """
    cache object should implement get and set method

    :param cache:
    :return:
    """
    if not cache:
        return True
    return all(map(lambda key: callable(getattr(cache, key, None)), ('get', 'set')))


class FlaskToken:
    """
    Default token strategy:
    The token is generated by pyjwt.
    And the token would be stored in redis when login successfully.
    """

    @check_argument(verify_cache, 'cache', is_func_decorated=False)
    def __init__(self, token_key: str, token_secrete_key: str,
                 cache: Optional[Any] = None, app: Optional[Flask] = None):
        """

        :param token_key: the token_key should be carried when http request
        :param token_secrete_key: encrypt or unencrypt will use it.
        :param cache:
            If not None, token info will be stored in redis,
            and cache object should implement get/set method, such as redis client.
        :param app: Flask instance
        """
        self.token_key = token_key
        self.token_secrete_key = token_secrete_key
        self.app = app
        self.cache = cache
        self._token = None

    @property
    def token(self):
        if not self._token:
            _get_token = partial(get_token, token_key=self.token_key)
            self._token = _get_token(from_url=False) or _get_token(from_url=True)
        return self._token

    def init_app(self, app: Flask):
        if not self.app:
            self.app = app

    def generate(self, raw_info: Dict, lifetime: int) -> str:
        token = pyjwt.encode(raw_info, self.token_secrete_key, lifetime=lifetime)
        if self.cache:
            self.cache.set(token, json.dumps(raw_info), lifetime)
        return token

    def verify(self, exclude_paths: Optional[Tuple] = None, allow_exception: bool = True) -> bool:
        """

        :param exclude_paths: exclude_paths do not verify token, such as '/login'
        :param token_key: token key.
        :return:

        usage:

        """
        if request.path in (exclude_paths or list()):
            return True
        if not is_valid(self.token, self.token_secrete_key):
            if allow_exception:
                raise ValueError(f'token {self.token} is invalid')
            return False
        if self.cache and not self.cache.get(self.token):
            if allow_exception:
                raise SystemError(f'token {self.token} do not exist in cache')
            return False
        return True

    def bound_cache_2_global(self, bound_list: Tuple) -> None:
        """
        bound cache info to flask.g
        :param bound_list:
        :return:
        """
        if not self.cache:
            raise SystemError(f'self.cache {self.cache} is invalid')
        cache: Dict = json.loads(self.cache.get(self.token))
        list(map(lambda key: setattr(g, key, cache.get(key)), bound_list))
