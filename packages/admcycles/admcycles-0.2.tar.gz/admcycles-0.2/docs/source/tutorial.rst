.. linkall

.. _tutorial:

admcycles Tutorial
==================

To use the module, the first thing you need to do is import it::

    sage: from admcycles import *

Then many functions become available. For example you can entering
tautological classes as combinations of divisors (here on `M_{3,4}`)::

    sage: t1=3*sepbdiv(1,(1,2),3,4)-psiclass(4,3,4)^2

And here on `M_{2,1}`::

    sage: g=2;n=1
    sage: reset_g_n(g, n)
    sage: t2=-1/3*irrbdiv()*lambdaclass(1)

Entering tautological classes - listing generators in given degree::

    sage: list_tautgens(2,0,2) #generators of R^2(\Mbar_{2,0})
    [0] : Graph :      [2] [[]] []
    Polynomial : 1*(kappa_2^1 )_0
    [1] : Graph :      [2] [[]] []
    Polynomial : 1*(kappa_1^2 )_0
    [2] : Graph :      [1, 1] [[2], [3]] [(2, 3)]
    Polynomial : 1*(kappa_1^1 )_0
    [3] : Graph :      [1, 1] [[2], [3]] [(2, 3)]
    Polynomial : 1*psi_2^1
    [4] : Graph :      [1] [[2, 3]] [(2, 3)]
    Polynomial : 1*(kappa_1^1 )_0
    [5] : Graph :      [1] [[2, 3]] [(2, 3)]
    Polynomial : 1*psi_2^1
    [6] : Graph :      [0, 1] [[3, 4, 5], [6]] [(3, 4), (5, 6)]
    Polynomial : 1*
    [7] : Graph :      [0] [[3, 4, 5, 6]] [(3, 4), (5, 6)]
    Polynomial : 1*
    sage: L=tautgens(2,0,2);
    sage: t3=2*L[3]+L[4]
    sage: t3
    Graph :      [1, 1] [[2], [3]] [(2, 3)]
    Polynomial : 2*psi_2^1
    <BLANKLINE>
    Graph :      [1] [[2, 3]] [(2, 3)]
    Polynomial : 1*(kappa_1^1 )_0

Entering a stable graph manually (the graph has two genus 1 components,
connected by an edge)::

    sage: stgraph([1,1],[[2],[3]],[(2,3)])
    [1, 1] [[2], [3]] [(2, 3)]

Basic operations with tautclasses::

    sage: s1=psiclass(3,1,3)^2 # psi_3 on \Mbar_{1,3}
    sage: s1.forgetful_pushforward([3]) # pi_* (psi_3) under map pi: \Mbar_{1,3} -> \Mbar_{1,2} forgetting marking 3
    Graph :      [1] [[1, 2]] []
    Polynomial : 1*(kappa_1^1 )_0

    sage: s2=psiclass(2,1,2)
    sage: s2.forgetful_pullback([3]) # pi^* (psi_2) under map pi: \Mbar_{1,3} -> \Mbar_{1,2}
    Graph :      [1] [[1, 2, 3]] []
    Polynomial : 1*psi_2^1
    <BLANKLINE>
    Graph :      [1, 0] [[1, 4], [5, 3, 2]] [(4, 5)]
    Polynomial : (-1)*


    sage: s3=psiclass(2,1,3)*psiclass(3,1,3)^2
    sage: s3.evaluate() # compute the degree of the zero cycle s3=psi_2*(psi_3)^2 on \Mbar_{1,3}
    1/12

    sage: s4=psiclass(2,1,2)^2+psiclass(1,1,2)*psiclass(2,1,2)
    sage: s4.evaluate()
    1/12

A basis of the tautological ring and tautological relations::

    sage: generating_indices(2,0,2) # gives list of indices of tautgens(2,0,2) forming a basis of R^2(\Mbar_{2,0})
    [0, 1]
    sage: t3.toTautbasis(2,0,2) # expresses class t3 in terms of this basis
    (-48, 22)

Verifying the divisor relation kappa - psi + delta_0 on `\bar M_{1,4}`::

    sage: g=1;n=4;
    sage: reset_g_n(g,n)
    sage: bgraphs=[bd for bd in list_strata(g,n,1) if bd.numvert()>1]
    sage: del0=sum([bd.to_tautclass() for bd in bgraphs]) # sum of boundary classes with separating node
    sage: psisum=sum([psiclass(i) for i in range(1,n+1)]) # sum of psi-classes
    sage: rel=kappaclass(1)-psisum+del0
    sage: rel.is_zero()
    True

Pulling back tautological classes to a boundary divisor::

    sage: bdry=stgraph([2,2],[[1],[2]],[(1,2)])
    sage: generator=tautgens(4,0,2)[3]
    sage: generator
    Graph :      [1, 3] [[2], [3]] [(2, 3)]
    Polynomial : 1*psi_3^1
    sage: pullback=bdry.boundary_pullback(generator); 
    sage: pullback.totensorTautbasis(2)
    [
                               [-3]
                               [ 1]
                      [0 0 0]  [-3]
                      [0 0 0]  [ 7]
    [-3  1 -3  7  1], [0 0 0], [ 1]
    ]
    sage: pullback.totensorTautbasis(2,vecout=true)
    (-3, 1, -3, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 1, -3, 7, 1)

Computing the cycle of the hyperelliptic locus in genus 3::

    sage: H=Hyperell(3,0,0)   # not tested

The cycle of hyperell. curves of genus 3 with 0 marked fixed points of
the involution and 0 marked pairs of conjugate points::

    sage: H.toTautbasis() # not tested

We compare with the known expression H=9*lambda-delta_0-3*delta_1::

    sage: g=3; n=0;
    sage: reset_g_n(g, n)
    sage: H2=9*lambdaclass(1)-(1/2)*irrbdiv()-3*sepbdiv(1,()) # not tested
    sage: H2.toTautbasis() # not tested

Specifying Hurwitz cycles::

    sage: G=PermutationGroup([(1,2)]) # G=Z/2Z
    sage: H=HurData(G,[G[1],G[1]]) # not tested # this means there are two ramification points with stabilizer generated by G[1], the generator of G

The following identify the locus of bielliptic curves (C,p,q) with
marked ramification points p,q in `\Mbar_{2,2}` in terms of the
generating set tautgens(2,2,3) of `R^3(\bar M_{2,2})`::

    sage: vbeta=Hidentify(2,H,vecout=true) # not tested
    sage: vector(vbeta) # not tested

    sage: H2=HurData(G,[G[1],G[1],G[0]]) # not tested

    sage: G=PermutationGroup([(1,2)]) # not tested
    sage: H=HurData(G,[G[1],G[1]]) # not tested

Identify the locus of bielliptic curves C, remembering none of the marked
ramification points, inside `\bar M_{2,0}`::

    sage: Biell=Hidentify(2,H,markings=[]) # not tested
    sage: Biell.toTautbasis(2,0,1) # not tested

    sage: g=2;n=0
    sage: reset_g_n(g, n)
    sage: Biell2=3/4*irrbdiv()+ 3*sepbdiv(1,()) # not tested # this is the formula for the bielliptic locus known from the literature
    sage: Biell2.toTautbasis(2,0,1) # not tested

Computing the Hurwitz Hodge integral \int_[\bar B_{2,2,0}] lambda_2::

    sage: (Biell*lambdaclass(2,2,0)).evaluate() # not tested # = 1/48
