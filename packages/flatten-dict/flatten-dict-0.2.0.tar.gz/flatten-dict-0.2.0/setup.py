# -*- coding: utf-8 -*-
from distutils.core import setup

package_dir = \
{'': 'src'}

packages = \
['flatten_dict']

package_data = \
{'': ['*'], 'flatten_dict': ['tests/*']}

install_requires = \
['pathlib2>=2.3,<3.0', 'six>=1.12,<2.0']

setup_kwargs = {
    'name': 'flatten-dict',
    'version': '0.2.0',
    'description': 'A flexible utility for flattening and unflattening dict-like objects in Python.',
    'long_description': 'flatten-dict\n============\n.. image:: https://img.shields.io/travis/ianlini/flatten-dict/master.svg\n   :target: https://travis-ci.org/ianlini/flatten-dict\n.. image:: https://img.shields.io/pypi/v/flatten-dict.svg\n   :target: https://pypi.python.org/pypi/flatten-dict\n.. image:: https://img.shields.io/pypi/l/flatten-dict.svg\n   :target: https://pypi.python.org/pypi/flatten-dict\n.. image:: https://img.shields.io/github/stars/ianlini/flatten-dict.svg?style=social\n   :target: https://github.com/ianlini/flatten-dict\n\nA flexible utility for flattening and unflattening dict-like objects in Python.\n\n\nIntroduction\n------------\nThis Python package provide a function ``flatten()`` for flattening dict-like objects.\nIt also provides some key joining methods (reducer), and you can choose the reducer you want or even implement your own reducer. You can also choose to invert the resulting flat dict.\n\nDocumentation\n-------------\n\nFlatten\n```````\n\n.. code-block:: python\n\n   def flatten(d, reducer=\'tuple\', inverse=False, enumerate_types=(), keep_empty_types=()):\n       """Flatten `Mapping` object.\n\n       Parameters\n       ----------\n       d : dict-like object\n           The dict that will be flattened.\n       reducer : {\'tuple\', \'path\', \'underscore\', Callable}\n           The key joining method. If a `Callable` is given, the `Callable` will be\n           used to reduce.\n           \'tuple\': The resulting key will be tuple of the original keys.\n           \'path\': Use `os.path.join` to join keys.\n           \'underscore\': Use underscores to join keys.\n       inverse : bool\n           Whether you want invert the resulting key and value.\n       enumerate_types : Sequence[type]\n           Flatten these types using `enumerate`.\n           For example, if we set `enumerate_types` to ``(list,)``,\n           `list` indices become keys: ``{\'a\': [\'b\', \'c\']}`` -> ``{(\'a\', 0): \'b\', (\'a\', 1): \'c\'}``.\n       keep_empty_types : Sequence[type]\n           By default, ``flatten({1: 2, 3: {}})`` will give you ``{(1,): 2}``, that is, the key ``3``\n           will disappear.\n           This is also applied for the types in `enumerate_types`, that is,\n           ``flatten({1: 2, 3: []}, enumerate_types=(list,))`` will give you ``{(1,): 2}``.\n           If you want to keep those empty values, you can specify the types in `keep_empty_types`:\n\n           >>> flatten({1: 2, 3: {}}, keep_empty_types=(dict,))\n           {(1,): 2, (3,): {}}\n\n       Returns\n       -------\n       flat_dict : dict\n       """\n\nExamples\n::::::::\n\n.. code-block:: python\n\n   In [1]: from flatten_dict import flatten\n\n   In [2]: normal_dict = {\n      ...:     \'a\': \'0\',\n      ...:     \'b\': {\n      ...:         \'a\': \'1.0\',\n      ...:         \'b\': \'1.1\',\n      ...:     },\n      ...:     \'c\': {\n      ...:         \'a\': \'2.0\',\n      ...:         \'b\': {\n      ...:             \'a\': \'2.1.0\',\n      ...:             \'b\': \'2.1.1\',\n      ...:         },\n      ...:     },\n      ...: }\n\n   In [3]: flatten(normal_dict)\n   Out[3]:\n   {(\'a\',): \'0\',\n    (\'b\', \'a\'): \'1.0\',\n    (\'b\', \'b\'): \'1.1\',\n    (\'c\', \'a\'): \'2.0\',\n    (\'c\', \'b\', \'a\'): \'2.1.0\',\n    (\'c\', \'b\', \'b\'): \'2.1.1\'}\n\n   In [4]: flatten(normal_dict, reducer=\'path\')\n   Out[4]:\n   {\'a\': \'0\',\n    \'b/a\': \'1.0\',\n    \'b/b\': \'1.1\',\n    \'c/a\': \'2.0\',\n    \'c/b/a\': \'2.1.0\',\n    \'c/b/b\': \'2.1.1\'}\n\n   In [5]: flatten(normal_dict, reducer=\'path\', inverse=True)\n   Out[5]:\n   {\'0\': \'a\',\n    \'1.0\': \'b/a\',\n    \'1.1\': \'b/b\',\n    \'2.0\': \'c/a\',\n    \'2.1.0\': \'c/b/a\',\n    \'2.1.1\': \'c/b/b\'}\n\n   In [6]: def underscore_reducer(k1, k2):\n      ...:     if k1 is None:\n      ...:         return k2\n      ...:     else:\n      ...:         return k1 + "_" + k2\n      ...:\n\n   In [7]: flatten(normal_dict, reducer=underscore_reducer)\n   Out[7]:\n   {\'a\': \'0\',\n    \'b_a\': \'1.0\',\n    \'b_b\': \'1.1\',\n    \'c_a\': \'2.0\',\n    \'c_b_a\': \'2.1.0\',\n    \'c_b_b\': \'2.1.1\'}\n\nIf we have some iterable (e.g., `list`) in the `dict`, we will normally get this:\n\n.. code-block:: python\n\n   In [8]: flatten({\'a\': [1, 2, 3], \'b\': \'c\'})\n   Out[8]:\n   {(\'a\',): [1, 2, 3],\n    (\'b\',): \'c\'}\n\nIf we want to use its indices as keys, then we can use the parameter `enumerate_types`:\n\n.. code-block:: python\n\n   In [9]: flatten({\'a\': [1, 2, 3], \'b\': \'c\'}, enumerate_types=(list,))\n   Out[9]:\n   {(\'a\', 0): 1,\n    (\'a\', 1): 2,\n    (\'a\', 2): 3,\n    (\'b\',): \'c\'}\n\nWe can even flatten a `list` directly:\n\n.. code-block:: python\n\n   In [10]: flatten([1, 2, 3], enumerate_types=(list,))\n   Out[10]:\n   {(0,): 1,\n    (1,): 2,\n    (2,): 3}\n\nIf there is an empty dict in the values, by default, it will disappear after flattened:\n\n.. code-block:: python\n\n   In [4]: flatten({1: 2, 3: {}})\n   Out[4]: {(1,): 2}\n\nWe can keep the empty dict in the result using ``keep_empty_types=(dict,)``:\n\n.. code-block:: python\n\n   In [5]: flatten({1: 2, 3: {}}, keep_empty_types=(dict,))\n   Out[5]: {(1,): 2, (3,): {}}\n\nUnflatten\n`````````\n\n.. code-block:: python\n\n   def unflatten(d, splitter=\'tuple\', inverse=False):\n       """Unflatten dict-like object.\n\n       Parameters\n       ----------\n       d : dict-like object\n           The dict that will be unflattened.\n       splitter : {\'tuple\', \'path\', \'underscore\', Callable}\n           The key splitting method. If a Callable is given, the Callable will be\n           used to split.\n           \'tuple\': Use each element in the tuple key as the key of the unflattened dict.\n           \'path\': Use `pathlib.Path.parts` to split keys.\n           \'underscore\': Use underscores to split keys.\n       inverse : bool\n           Whether you want to invert the key and value before flattening.\n\n       Returns\n       -------\n       unflattened_dict : dict\n       """\n\nExamples\n::::::::\n\n.. code-block:: python\n\n   In [1]: from flatten_dict import unflatten\n\n   In [2]: flat_dict = {\n      ...:     (\'a\',): \'0\',\n      ...:     (\'b\', \'a\'): \'1.0\',\n      ...:     (\'b\', \'b\'): \'1.1\',\n      ...:     (\'c\', \'a\'): \'2.0\',\n      ...:     (\'c\', \'b\', \'a\'): \'2.1.0\',\n      ...:     (\'c\', \'b\', \'b\'): \'2.1.1\',\n      ...: }\n\n   In [3]: unflatten(flat_dict)\n   Out[3]:\n   {\'a\': \'0\',\n    \'b\': {\'a\': \'1.0\', \'b\': \'1.1\'},\n    \'c\': {\'a\': \'2.0\', \'b\': {\'a\': \'2.1.0\', \'b\': \'2.1.1\'}}}\n\n   In [4]: flat_dict = {\n      ...:     \'a\': \'0\',\n      ...:     \'b/a\': \'1.0\',\n      ...:     \'b/b\': \'1.1\',\n      ...:     \'c/a\': \'2.0\',\n      ...:     \'c/b/a\': \'2.1.0\',\n      ...:     \'c/b/b\': \'2.1.1\',\n      ...: }\n\n   In [5]: unflatten(flat_dict, splitter=\'path\')\n   Out[5]:\n   {\'a\': \'0\',\n    \'b\': {\'a\': \'1.0\', \'b\': \'1.1\'},\n    \'c\': {\'a\': \'2.0\', \'b\': {\'a\': \'2.1.0\', \'b\': \'2.1.1\'}}}\n\n   In [6]: flat_dict = {\n      ...:     \'0\': \'a\',\n      ...:     \'1.0\': \'b/a\',\n      ...:     \'1.1\': \'b/b\',\n      ...:     \'2.0\': \'c/a\',\n      ...:     \'2.1.0\': \'c/b/a\',\n      ...:     \'2.1.1\': \'c/b/b\',\n      ...: }\n\n   In [7]: unflatten(flat_dict, splitter=\'path\', inverse=True)\n   Out[7]:\n   {\'a\': \'0\',\n    \'b\': {\'a\': \'1.0\', \'b\': \'1.1\'},\n    \'c\': {\'a\': \'2.0\', \'b\': {\'a\': \'2.1.0\', \'b\': \'2.1.1\'}}}\n\n   In [8]: def underscore_splitter(flat_key):\n      ...:     return flat_key.split("_")\n      ...:\n\n   In [9]: flat_dict = {\n      ...:     \'a\': \'0\',\n      ...:     \'b_a\': \'1.0\',\n      ...:     \'b_b\': \'1.1\',\n      ...:     \'c_a\': \'2.0\',\n      ...:     \'c_b_a\': \'2.1.0\',\n      ...:     \'c_b_b\': \'2.1.1\',\n      ...: }\n\n   In [10]: unflatten(flat_dict, splitter=underscore_splitter)\n   Out[10]:\n   {\'a\': \'0\',\n    \'b\': {\'a\': \'1.0\', \'b\': \'1.1\'},\n    \'c\': {\'a\': \'2.0\', \'b\': {\'a\': \'2.1.0\', \'b\': \'2.1.1\'}}}\n',
    'author': 'Ian Lin',
    'author_email': 'you@example.com',
    'url': 'https://github.com/ianlini/flatten-dict',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*',
}


setup(**setup_kwargs)
