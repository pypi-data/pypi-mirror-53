# coding: utf-8

"""
    Cloudera Edge Flow Manager REST API

    This REST API provides remote access to the EFM Server.                                             Endpoints that are marked as [BETA] are subject to change in future releases of the application without backwards compatibility and without a major version change.

    OpenAPI spec version: 1.0.0-SNAPSHOT
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class FlowDesignerApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def create_connection(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a connection in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_connection(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDConnection body: The configuration details. (required)
        :return: FDConnection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_connection_with_http_info(flow_id, pg_id, body, **kwargs)
        else:
            (data) = self.create_connection_with_http_info(flow_id, pg_id, body, **kwargs)
            return data

    def create_connection_with_http_info(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a connection in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_connection_with_http_info(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDConnection body: The configuration details. (required)
        :return: FDConnection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'pg_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_connection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `create_connection`")
        # verify the required parameter 'pg_id' is set
        if ('pg_id' not in params) or (params['pg_id'] is None):
            raise ValueError("Missing the required parameter `pg_id` when calling `create_connection`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_connection`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'pg_id' in params:
            path_params['pgId'] = params['pg_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/process-groups/{pgId}/connections', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDConnection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_controller_service(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a controller service in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_controller_service(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDControllerService body: The configuration details. (required)
        :return: FDControllerService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_controller_service_with_http_info(flow_id, pg_id, body, **kwargs)
        else:
            (data) = self.create_controller_service_with_http_info(flow_id, pg_id, body, **kwargs)
            return data

    def create_controller_service_with_http_info(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a controller service in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_controller_service_with_http_info(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDControllerService body: The configuration details. (required)
        :return: FDControllerService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'pg_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_controller_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `create_controller_service`")
        # verify the required parameter 'pg_id' is set
        if ('pg_id' not in params) or (params['pg_id'] is None):
            raise ValueError("Missing the required parameter `pg_id` when calling `create_controller_service`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_controller_service`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'pg_id' in params:
            path_params['pgId'] = params['pg_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/process-groups/{pgId}/controller-services', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDControllerService',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_funnel(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a funnel in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_funnel(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDFunnel body: The configuration details. (required)
        :return: FDFunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_funnel_with_http_info(flow_id, pg_id, body, **kwargs)
        else:
            (data) = self.create_funnel_with_http_info(flow_id, pg_id, body, **kwargs)
            return data

    def create_funnel_with_http_info(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a funnel in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_funnel_with_http_info(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDFunnel body: The configuration details. (required)
        :return: FDFunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'pg_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_funnel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `create_funnel`")
        # verify the required parameter 'pg_id' is set
        if ('pg_id' not in params) or (params['pg_id'] is None):
            raise ValueError("Missing the required parameter `pg_id` when calling `create_funnel`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_funnel`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'pg_id' in params:
            path_params['pgId'] = params['pg_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/process-groups/{pgId}/funnels', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDFunnel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_processor(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a processor in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_processor(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDProcessor body: The processor configuration details. (required)
        :return: FDProcessor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_processor_with_http_info(flow_id, pg_id, body, **kwargs)
        else:
            (data) = self.create_processor_with_http_info(flow_id, pg_id, body, **kwargs)
            return data

    def create_processor_with_http_info(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a processor in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_processor_with_http_info(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDProcessor body: The processor configuration details. (required)
        :return: FDProcessor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'pg_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_processor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `create_processor`")
        # verify the required parameter 'pg_id' is set
        if ('pg_id' not in params) or (params['pg_id'] is None):
            raise ValueError("Missing the required parameter `pg_id` when calling `create_processor`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_processor`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'pg_id' in params:
            path_params['pgId'] = params['pg_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/process-groups/{pgId}/processors', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDProcessor',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_remote_process_group(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a remote process group in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_remote_process_group(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDRemoteProcessGroup body: The configuration details. (required)
        :return: FDRemoteProcessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_remote_process_group_with_http_info(flow_id, pg_id, body, **kwargs)
        else:
            (data) = self.create_remote_process_group_with_http_info(flow_id, pg_id, body, **kwargs)
            return data

    def create_remote_process_group_with_http_info(self, flow_id, pg_id, body, **kwargs):
        """
        Creates a remote process group in the given process group
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_remote_process_group_with_http_info(flow_id, pg_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param FDRemoteProcessGroup body: The configuration details. (required)
        :return: FDRemoteProcessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'pg_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_remote_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `create_remote_process_group`")
        # verify the required parameter 'pg_id' is set
        if ('pg_id' not in params) or (params['pg_id'] is None):
            raise ValueError("Missing the required parameter `pg_id` when calling `create_remote_process_group`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_remote_process_group`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'pg_id' in params:
            path_params['pgId'] = params['pg_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/process-groups/{pgId}/remote-process-groups', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDRemoteProcessGroup',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_connection(self, flow_id, connection_id, **kwargs):
        """
        Deletes the connection with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_connection(flow_id, connection_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str connection_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDConnection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_connection_with_http_info(flow_id, connection_id, **kwargs)
        else:
            (data) = self.delete_connection_with_http_info(flow_id, connection_id, **kwargs)
            return data

    def delete_connection_with_http_info(self, flow_id, connection_id, **kwargs):
        """
        Deletes the connection with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_connection_with_http_info(flow_id, connection_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str connection_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDConnection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'connection_id', 'version', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_connection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `delete_connection`")
        # verify the required parameter 'connection_id' is set
        if ('connection_id' not in params) or (params['connection_id'] is None):
            raise ValueError("Missing the required parameter `connection_id` when calling `delete_connection`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'connection_id' in params:
            path_params['connectionId'] = params['connection_id']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))
        if 'client_id' in params:
            query_params.append(('clientId', params['client_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/connections/{connectionId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDConnection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_controller_service(self, flow_id, controller_service_id, **kwargs):
        """
        Deletes the controller service with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_controller_service(flow_id, controller_service_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str controller_service_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDControllerService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_controller_service_with_http_info(flow_id, controller_service_id, **kwargs)
        else:
            (data) = self.delete_controller_service_with_http_info(flow_id, controller_service_id, **kwargs)
            return data

    def delete_controller_service_with_http_info(self, flow_id, controller_service_id, **kwargs):
        """
        Deletes the controller service with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_controller_service_with_http_info(flow_id, controller_service_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str controller_service_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDControllerService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'controller_service_id', 'version', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_controller_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `delete_controller_service`")
        # verify the required parameter 'controller_service_id' is set
        if ('controller_service_id' not in params) or (params['controller_service_id'] is None):
            raise ValueError("Missing the required parameter `controller_service_id` when calling `delete_controller_service`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'controller_service_id' in params:
            path_params['controllerServiceId'] = params['controller_service_id']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))
        if 'client_id' in params:
            query_params.append(('clientId', params['client_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/controller-services/{controllerServiceId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDControllerService',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_flow(self, flow_id, **kwargs):
        """
        Deletes the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_flow(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDFlowMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_flow_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.delete_flow_with_http_info(flow_id, **kwargs)
            return data

    def delete_flow_with_http_info(self, flow_id, **kwargs):
        """
        Deletes the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_flow_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDFlowMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_flow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `delete_flow`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDFlowMetadata',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_funnel(self, flow_id, funnel_id, **kwargs):
        """
        Deletes the funnel with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_funnel(flow_id, funnel_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str funnel_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDFunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_funnel_with_http_info(flow_id, funnel_id, **kwargs)
        else:
            (data) = self.delete_funnel_with_http_info(flow_id, funnel_id, **kwargs)
            return data

    def delete_funnel_with_http_info(self, flow_id, funnel_id, **kwargs):
        """
        Deletes the funnel with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_funnel_with_http_info(flow_id, funnel_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str funnel_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDFunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'funnel_id', 'version', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_funnel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `delete_funnel`")
        # verify the required parameter 'funnel_id' is set
        if ('funnel_id' not in params) or (params['funnel_id'] is None):
            raise ValueError("Missing the required parameter `funnel_id` when calling `delete_funnel`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'funnel_id' in params:
            path_params['funnelId'] = params['funnel_id']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))
        if 'client_id' in params:
            query_params.append(('clientId', params['client_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/funnels/{funnelId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDFunnel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_processor(self, flow_id, processor_id, **kwargs):
        """
        Deletes the processor with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_processor(flow_id, processor_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str processor_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDProcessor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_processor_with_http_info(flow_id, processor_id, **kwargs)
        else:
            (data) = self.delete_processor_with_http_info(flow_id, processor_id, **kwargs)
            return data

    def delete_processor_with_http_info(self, flow_id, processor_id, **kwargs):
        """
        Deletes the processor with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_processor_with_http_info(flow_id, processor_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str processor_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDProcessor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'processor_id', 'version', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_processor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `delete_processor`")
        # verify the required parameter 'processor_id' is set
        if ('processor_id' not in params) or (params['processor_id'] is None):
            raise ValueError("Missing the required parameter `processor_id` when calling `delete_processor`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'processor_id' in params:
            path_params['processorId'] = params['processor_id']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))
        if 'client_id' in params:
            query_params.append(('clientId', params['client_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/processors/{processorId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDProcessor',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_remote_process_group(self, flow_id, remote_process_group_id, **kwargs):
        """
        Deletes the remote process group with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_remote_process_group(flow_id, remote_process_group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str remote_process_group_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDRemoteProcessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_remote_process_group_with_http_info(flow_id, remote_process_group_id, **kwargs)
        else:
            (data) = self.delete_remote_process_group_with_http_info(flow_id, remote_process_group_id, **kwargs)
            return data

    def delete_remote_process_group_with_http_info(self, flow_id, remote_process_group_id, **kwargs):
        """
        Deletes the remote process group with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_remote_process_group_with_http_info(flow_id, remote_process_group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str remote_process_group_id: (required)
        :param str version: The revision is used to verify the client is working with the latest version of the flow.
        :param str client_id: If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
        :return: FDRemoteProcessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'remote_process_group_id', 'version', 'client_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_remote_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `delete_remote_process_group`")
        # verify the required parameter 'remote_process_group_id' is set
        if ('remote_process_group_id' not in params) or (params['remote_process_group_id'] is None):
            raise ValueError("Missing the required parameter `remote_process_group_id` when calling `delete_remote_process_group`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'remote_process_group_id' in params:
            path_params['remoteProcessGroupId'] = params['remote_process_group_id']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))
        if 'client_id' in params:
            query_params.append(('clientId', params['client_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/remote-process-groups/{remoteProcessGroupId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDRemoteProcessGroup',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_client_id(self, **kwargs):
        """
        Gets a client id to use with the designer endpoints
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_client_id(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_client_id_with_http_info(**kwargs)
        else:
            (data) = self.get_client_id_with_http_info(**kwargs)
            return data

    def get_client_id_with_http_info(self, **kwargs):
        """
        Gets a client id to use with the designer endpoints
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_client_id_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/client-id', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_connection(self, flow_id, connection_id, **kwargs):
        """
        Retrieves the connection with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_connection(flow_id, connection_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str connection_id: (required)
        :return: FDConnection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_connection_with_http_info(flow_id, connection_id, **kwargs)
        else:
            (data) = self.get_connection_with_http_info(flow_id, connection_id, **kwargs)
            return data

    def get_connection_with_http_info(self, flow_id, connection_id, **kwargs):
        """
        Retrieves the connection with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_connection_with_http_info(flow_id, connection_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str connection_id: (required)
        :return: FDConnection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'connection_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_connection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_connection`")
        # verify the required parameter 'connection_id' is set
        if ('connection_id' not in params) or (params['connection_id'] is None):
            raise ValueError("Missing the required parameter `connection_id` when calling `get_connection`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'connection_id' in params:
            path_params['connectionId'] = params['connection_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/connections/{connectionId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDConnection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_controller_service(self, flow_id, controller_service_id, **kwargs):
        """
        Retrieves the controller service with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_controller_service(flow_id, controller_service_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str controller_service_id: (required)
        :return: FDControllerService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_controller_service_with_http_info(flow_id, controller_service_id, **kwargs)
        else:
            (data) = self.get_controller_service_with_http_info(flow_id, controller_service_id, **kwargs)
            return data

    def get_controller_service_with_http_info(self, flow_id, controller_service_id, **kwargs):
        """
        Retrieves the controller service with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_controller_service_with_http_info(flow_id, controller_service_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str controller_service_id: (required)
        :return: FDControllerService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'controller_service_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_controller_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_controller_service`")
        # verify the required parameter 'controller_service_id' is set
        if ('controller_service_id' not in params) or (params['controller_service_id'] is None):
            raise ValueError("Missing the required parameter `controller_service_id` when calling `get_controller_service`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'controller_service_id' in params:
            path_params['controllerServiceId'] = params['controller_service_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/controller-services/{controllerServiceId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDControllerService',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_controller_service_property_descriptor(self, flow_id, controller_service_id, property_name, **kwargs):
        """
        Retrieves the property descriptor with the given name for the given service in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_controller_service_property_descriptor(flow_id, controller_service_id, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str controller_service_id: (required)
        :param str property_name: (required)
        :return: FDPropertyDescriptor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_controller_service_property_descriptor_with_http_info(flow_id, controller_service_id, property_name, **kwargs)
        else:
            (data) = self.get_controller_service_property_descriptor_with_http_info(flow_id, controller_service_id, property_name, **kwargs)
            return data

    def get_controller_service_property_descriptor_with_http_info(self, flow_id, controller_service_id, property_name, **kwargs):
        """
        Retrieves the property descriptor with the given name for the given service in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_controller_service_property_descriptor_with_http_info(flow_id, controller_service_id, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str controller_service_id: (required)
        :param str property_name: (required)
        :return: FDPropertyDescriptor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'controller_service_id', 'property_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_controller_service_property_descriptor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_controller_service_property_descriptor`")
        # verify the required parameter 'controller_service_id' is set
        if ('controller_service_id' not in params) or (params['controller_service_id'] is None):
            raise ValueError("Missing the required parameter `controller_service_id` when calling `get_controller_service_property_descriptor`")
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params) or (params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `get_controller_service_property_descriptor`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'controller_service_id' in params:
            path_params['controllerServiceId'] = params['controller_service_id']
        if 'property_name' in params:
            path_params['propertyName'] = params['property_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/controller-services/{controllerServiceId}/descriptors/{propertyName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDPropertyDescriptor',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_controller_service_types(self, flow_id, **kwargs):
        """
        Gets the available controller service types for the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_controller_service_types(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDComponentTypes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_controller_service_types_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.get_controller_service_types_with_http_info(flow_id, **kwargs)
            return data

    def get_controller_service_types_with_http_info(self, flow_id, **kwargs):
        """
        Gets the available controller service types for the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_controller_service_types_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDComponentTypes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_controller_service_types" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_controller_service_types`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/types/controller-services', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDComponentTypes',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_controller_services(self, flow_id, pg_id, **kwargs):
        """
        Retrieves the controller service with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_controller_services(flow_id, pg_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :return: ListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_controller_services_with_http_info(flow_id, pg_id, **kwargs)
        else:
            (data) = self.get_controller_services_with_http_info(flow_id, pg_id, **kwargs)
            return data

    def get_controller_services_with_http_info(self, flow_id, pg_id, **kwargs):
        """
        Retrieves the controller service with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_controller_services_with_http_info(flow_id, pg_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :return: ListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'pg_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_controller_services" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_controller_services`")
        # verify the required parameter 'pg_id' is set
        if ('pg_id' not in params) or (params['pg_id'] is None):
            raise ValueError("Missing the required parameter `pg_id` when calling `get_controller_services`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'pg_id' in params:
            path_params['pgId'] = params['pg_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/process-groups/{pgId}/controller-services', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListContainer',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_el_specification(self, flow_id, **kwargs):
        """
        Gets the expression language specification for the agent class of the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_el_specification(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: ELSpecification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_el_specification_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.get_el_specification_with_http_info(flow_id, **kwargs)
            return data

    def get_el_specification_with_http_info(self, flow_id, **kwargs):
        """
        Gets the expression language specification for the agent class of the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_el_specification_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: ELSpecification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_el_specification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_el_specification`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/expression-language-spec', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ELSpecification',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_flow(self, flow_id, **kwargs):
        """
        Gets the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDFlow
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_flow_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.get_flow_with_http_info(flow_id, **kwargs)
            return data

    def get_flow_with_http_info(self, flow_id, **kwargs):
        """
        Gets the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDFlow
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_flow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_flow`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDFlow',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_flow_events(self, flow_id, **kwargs):
        """
        Gets the flow events for the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_events(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: ListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_flow_events_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.get_flow_events_with_http_info(flow_id, **kwargs)
            return data

    def get_flow_events_with_http_info(self, flow_id, **kwargs):
        """
        Gets the flow events for the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_events_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: ListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_flow_events" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_flow_events`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/events', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListContainer',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_flow_metadata(self, flow_id, **kwargs):
        """
        Gets the flow metadata for the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_metadata(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDFlowMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_flow_metadata_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.get_flow_metadata_with_http_info(flow_id, **kwargs)
            return data

    def get_flow_metadata_with_http_info(self, flow_id, **kwargs):
        """
        Gets the flow metadata for the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_metadata_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDFlowMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_flow_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_flow_metadata`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/metadata', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDFlowMetadata',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_flow_summaries(self, **kwargs):
        """
        Gets the summaries of the available flows known to the flow designer
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_summaries(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_flow_summaries_with_http_info(**kwargs)
        else:
            (data) = self.get_flow_summaries_with_http_info(**kwargs)
            return data

    def get_flow_summaries_with_http_info(self, **kwargs):
        """
        Gets the summaries of the available flows known to the flow designer
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_summaries_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_flow_summaries" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/summaries', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListContainer',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_flow_version_info(self, flow_id, **kwargs):
        """
        Gets the version info for the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_version_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDVersionInfoResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_flow_version_info_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.get_flow_version_info_with_http_info(flow_id, **kwargs)
            return data

    def get_flow_version_info_with_http_info(self, flow_id, **kwargs):
        """
        Gets the version info for the flow with the given id
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flow_version_info_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDVersionInfoResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_flow_version_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_flow_version_info`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/version-info', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDVersionInfoResult',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_flows(self, **kwargs):
        """
        Gets the available flows known to the flow designer
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flows(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_flows_with_http_info(**kwargs)
        else:
            (data) = self.get_flows_with_http_info(**kwargs)
            return data

    def get_flows_with_http_info(self, **kwargs):
        """
        Gets the available flows known to the flow designer
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_flows_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_flows" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListContainer',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_funnel(self, flow_id, funnel_id, **kwargs):
        """
        Retrieves the funnel with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_funnel(flow_id, funnel_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str funnel_id: (required)
        :return: FDFunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_funnel_with_http_info(flow_id, funnel_id, **kwargs)
        else:
            (data) = self.get_funnel_with_http_info(flow_id, funnel_id, **kwargs)
            return data

    def get_funnel_with_http_info(self, flow_id, funnel_id, **kwargs):
        """
        Retrieves the funnel with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_funnel_with_http_info(flow_id, funnel_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str funnel_id: (required)
        :return: FDFunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'funnel_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_funnel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_funnel`")
        # verify the required parameter 'funnel_id' is set
        if ('funnel_id' not in params) or (params['funnel_id'] is None):
            raise ValueError("Missing the required parameter `funnel_id` when calling `get_funnel`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'funnel_id' in params:
            path_params['funnelId'] = params['funnel_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/funnels/{funnelId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDFunnel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_process_group(self, flow_id, pg_id, **kwargs):
        """
        Retrieves the process group with the given id in the given flow. The alias of 'root' may be used to retrieve the root process group for the given flow.
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_process_group(flow_id, pg_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param bool include_children:
        :return: FDProcessGroupFlow
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_process_group_with_http_info(flow_id, pg_id, **kwargs)
        else:
            (data) = self.get_process_group_with_http_info(flow_id, pg_id, **kwargs)
            return data

    def get_process_group_with_http_info(self, flow_id, pg_id, **kwargs):
        """
        Retrieves the process group with the given id in the given flow. The alias of 'root' may be used to retrieve the root process group for the given flow.
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_process_group_with_http_info(flow_id, pg_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str pg_id: (required)
        :param bool include_children:
        :return: FDProcessGroupFlow
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'pg_id', 'include_children']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_process_group`")
        # verify the required parameter 'pg_id' is set
        if ('pg_id' not in params) or (params['pg_id'] is None):
            raise ValueError("Missing the required parameter `pg_id` when calling `get_process_group`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'pg_id' in params:
            path_params['pgId'] = params['pg_id']

        query_params = []
        if 'include_children' in params:
            query_params.append(('includeChildren', params['include_children']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/process-groups/{pgId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDProcessGroupFlow',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_processor(self, flow_id, processor_id, **kwargs):
        """
        Retrieves the processor with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_processor(flow_id, processor_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str processor_id: (required)
        :return: FDProcessor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_processor_with_http_info(flow_id, processor_id, **kwargs)
        else:
            (data) = self.get_processor_with_http_info(flow_id, processor_id, **kwargs)
            return data

    def get_processor_with_http_info(self, flow_id, processor_id, **kwargs):
        """
        Retrieves the processor with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_processor_with_http_info(flow_id, processor_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str processor_id: (required)
        :return: FDProcessor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'processor_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_processor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_processor`")
        # verify the required parameter 'processor_id' is set
        if ('processor_id' not in params) or (params['processor_id'] is None):
            raise ValueError("Missing the required parameter `processor_id` when calling `get_processor`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'processor_id' in params:
            path_params['processorId'] = params['processor_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/processors/{processorId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDProcessor',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_processor_property_descriptor(self, flow_id, processor_id, property_name, **kwargs):
        """
        Retrieves the property descriptor with the given name from the given processor in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_processor_property_descriptor(flow_id, processor_id, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str processor_id: (required)
        :param str property_name: (required)
        :return: FDPropertyDescriptor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_processor_property_descriptor_with_http_info(flow_id, processor_id, property_name, **kwargs)
        else:
            (data) = self.get_processor_property_descriptor_with_http_info(flow_id, processor_id, property_name, **kwargs)
            return data

    def get_processor_property_descriptor_with_http_info(self, flow_id, processor_id, property_name, **kwargs):
        """
        Retrieves the property descriptor with the given name from the given processor in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_processor_property_descriptor_with_http_info(flow_id, processor_id, property_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str processor_id: (required)
        :param str property_name: (required)
        :return: FDPropertyDescriptor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'processor_id', 'property_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_processor_property_descriptor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_processor_property_descriptor`")
        # verify the required parameter 'processor_id' is set
        if ('processor_id' not in params) or (params['processor_id'] is None):
            raise ValueError("Missing the required parameter `processor_id` when calling `get_processor_property_descriptor`")
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params) or (params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `get_processor_property_descriptor`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'processor_id' in params:
            path_params['processorId'] = params['processor_id']
        if 'property_name' in params:
            path_params['propertyName'] = params['property_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/processors/{processorId}/descriptors/{propertyName}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDPropertyDescriptor',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_processor_types(self, flow_id, **kwargs):
        """
        Gets the available processor types for the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_processor_types(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDComponentTypes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_processor_types_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.get_processor_types_with_http_info(flow_id, **kwargs)
            return data

    def get_processor_types_with_http_info(self, flow_id, **kwargs):
        """
        Gets the available processor types for the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_processor_types_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDComponentTypes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_processor_types" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_processor_types`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/types/processors', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDComponentTypes',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_remote_process_group(self, flow_id, remote_process_group_id, **kwargs):
        """
        Retrieves the remote process group with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_remote_process_group(flow_id, remote_process_group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str remote_process_group_id: (required)
        :return: FDRemoteProcessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_remote_process_group_with_http_info(flow_id, remote_process_group_id, **kwargs)
        else:
            (data) = self.get_remote_process_group_with_http_info(flow_id, remote_process_group_id, **kwargs)
            return data

    def get_remote_process_group_with_http_info(self, flow_id, remote_process_group_id, **kwargs):
        """
        Retrieves the remote process group with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_remote_process_group_with_http_info(flow_id, remote_process_group_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str remote_process_group_id: (required)
        :return: FDRemoteProcessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'remote_process_group_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remote_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `get_remote_process_group`")
        # verify the required parameter 'remote_process_group_id' is set
        if ('remote_process_group_id' not in params) or (params['remote_process_group_id'] is None):
            raise ValueError("Missing the required parameter `remote_process_group_id` when calling `get_remote_process_group`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'remote_process_group_id' in params:
            path_params['remoteProcessGroupId'] = params['remote_process_group_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/remote-process-groups/{remoteProcessGroupId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDRemoteProcessGroup',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def publish_flow(self, flow_id, **kwargs):
        """
        Publishes the current state of the flow to NiFi Registry
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.publish_flow(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param FDFlowPublishMetadata body: The metadata for publishing the flow, such as comments
        :return: FDVersionInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.publish_flow_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.publish_flow_with_http_info(flow_id, **kwargs)
            return data

    def publish_flow_with_http_info(self, flow_id, **kwargs):
        """
        Publishes the current state of the flow to NiFi Registry
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.publish_flow_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param FDFlowPublishMetadata body: The metadata for publishing the flow, such as comments
        :return: FDVersionInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_flow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `publish_flow`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/publish', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDVersionInfo',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def revert_flow(self, flow_id, **kwargs):
        """
        Reverts the current state of the flow to the last published version. If the flow has never been published, or has no changes to publish, then this will be a no-op.
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.revert_flow(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDVersionInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.revert_flow_with_http_info(flow_id, **kwargs)
        else:
            (data) = self.revert_flow_with_http_info(flow_id, **kwargs)
            return data

    def revert_flow_with_http_info(self, flow_id, **kwargs):
        """
        Reverts the current state of the flow to the last published version. If the flow has never been published, or has no changes to publish, then this will be a no-op.
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.revert_flow_with_http_info(flow_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :return: FDVersionInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revert_flow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `revert_flow`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/revert', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDVersionInfo',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_connection(self, flow_id, connection_id, body, **kwargs):
        """
        Updates the connection with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_connection(flow_id, connection_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str connection_id: (required)
        :param FDConnection body: The connection configuration details. (required)
        :return: FDConnection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_connection_with_http_info(flow_id, connection_id, body, **kwargs)
        else:
            (data) = self.update_connection_with_http_info(flow_id, connection_id, body, **kwargs)
            return data

    def update_connection_with_http_info(self, flow_id, connection_id, body, **kwargs):
        """
        Updates the connection with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_connection_with_http_info(flow_id, connection_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str connection_id: (required)
        :param FDConnection body: The connection configuration details. (required)
        :return: FDConnection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'connection_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_connection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `update_connection`")
        # verify the required parameter 'connection_id' is set
        if ('connection_id' not in params) or (params['connection_id'] is None):
            raise ValueError("Missing the required parameter `connection_id` when calling `update_connection`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_connection`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'connection_id' in params:
            path_params['connectionId'] = params['connection_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/connections/{connectionId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDConnection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_controller_service(self, flow_id, controller_service_id, body, **kwargs):
        """
        Updates the controller service with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_controller_service(flow_id, controller_service_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str controller_service_id: (required)
        :param FDControllerService body: The controller service configuration details. (required)
        :return: FDControllerService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_controller_service_with_http_info(flow_id, controller_service_id, body, **kwargs)
        else:
            (data) = self.update_controller_service_with_http_info(flow_id, controller_service_id, body, **kwargs)
            return data

    def update_controller_service_with_http_info(self, flow_id, controller_service_id, body, **kwargs):
        """
        Updates the controller service with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_controller_service_with_http_info(flow_id, controller_service_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str controller_service_id: (required)
        :param FDControllerService body: The controller service configuration details. (required)
        :return: FDControllerService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'controller_service_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_controller_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `update_controller_service`")
        # verify the required parameter 'controller_service_id' is set
        if ('controller_service_id' not in params) or (params['controller_service_id'] is None):
            raise ValueError("Missing the required parameter `controller_service_id` when calling `update_controller_service`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_controller_service`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'controller_service_id' in params:
            path_params['controllerServiceId'] = params['controller_service_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/controller-services/{controllerServiceId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDControllerService',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_funnel(self, flow_id, funnel_id, body, **kwargs):
        """
        Updates the funnel with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_funnel(flow_id, funnel_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str funnel_id: (required)
        :param FDFunnel body: The funnel configuration details. (required)
        :return: FDFunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_funnel_with_http_info(flow_id, funnel_id, body, **kwargs)
        else:
            (data) = self.update_funnel_with_http_info(flow_id, funnel_id, body, **kwargs)
            return data

    def update_funnel_with_http_info(self, flow_id, funnel_id, body, **kwargs):
        """
        Updates the funnel with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_funnel_with_http_info(flow_id, funnel_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str funnel_id: (required)
        :param FDFunnel body: The funnel configuration details. (required)
        :return: FDFunnel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'funnel_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_funnel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `update_funnel`")
        # verify the required parameter 'funnel_id' is set
        if ('funnel_id' not in params) or (params['funnel_id'] is None):
            raise ValueError("Missing the required parameter `funnel_id` when calling `update_funnel`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_funnel`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'funnel_id' in params:
            path_params['funnelId'] = params['funnel_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/funnels/{funnelId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDFunnel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_processor(self, flow_id, processor_id, body, **kwargs):
        """
        Updates the processor with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_processor(flow_id, processor_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str processor_id: (required)
        :param FDProcessor body: The processor configuration details. (required)
        :return: FDProcessor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_processor_with_http_info(flow_id, processor_id, body, **kwargs)
        else:
            (data) = self.update_processor_with_http_info(flow_id, processor_id, body, **kwargs)
            return data

    def update_processor_with_http_info(self, flow_id, processor_id, body, **kwargs):
        """
        Updates the processor with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_processor_with_http_info(flow_id, processor_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str processor_id: (required)
        :param FDProcessor body: The processor configuration details. (required)
        :return: FDProcessor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'processor_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_processor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `update_processor`")
        # verify the required parameter 'processor_id' is set
        if ('processor_id' not in params) or (params['processor_id'] is None):
            raise ValueError("Missing the required parameter `processor_id` when calling `update_processor`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_processor`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'processor_id' in params:
            path_params['processorId'] = params['processor_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/processors/{processorId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDProcessor',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_remote_process_group(self, flow_id, remote_process_group_id, body, **kwargs):
        """
        Updates the remote process group with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_remote_process_group(flow_id, remote_process_group_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str remote_process_group_id: (required)
        :param FDRemoteProcessGroup body: The remoteProcessGroup configuration details. (required)
        :return: FDRemoteProcessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_remote_process_group_with_http_info(flow_id, remote_process_group_id, body, **kwargs)
        else:
            (data) = self.update_remote_process_group_with_http_info(flow_id, remote_process_group_id, body, **kwargs)
            return data

    def update_remote_process_group_with_http_info(self, flow_id, remote_process_group_id, body, **kwargs):
        """
        Updates the remote process group with the given id in the given flow
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_remote_process_group_with_http_info(flow_id, remote_process_group_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str flow_id: (required)
        :param str remote_process_group_id: (required)
        :param FDRemoteProcessGroup body: The remoteProcessGroup configuration details. (required)
        :return: FDRemoteProcessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['flow_id', 'remote_process_group_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_remote_process_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'flow_id' is set
        if ('flow_id' not in params) or (params['flow_id'] is None):
            raise ValueError("Missing the required parameter `flow_id` when calling `update_remote_process_group`")
        # verify the required parameter 'remote_process_group_id' is set
        if ('remote_process_group_id' not in params) or (params['remote_process_group_id'] is None):
            raise ValueError("Missing the required parameter `remote_process_group_id` when calling `update_remote_process_group`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_remote_process_group`")


        collection_formats = {}

        path_params = {}
        if 'flow_id' in params:
            path_params['flowId'] = params['flow_id']
        if 'remote_process_group_id' in params:
            path_params['remoteProcessGroupId'] = params['remote_process_group_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['tokenAuth']

        return self.api_client.call_api('/designer/flows/{flowId}/remote-process-groups/{remoteProcessGroupId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FDRemoteProcessGroup',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
