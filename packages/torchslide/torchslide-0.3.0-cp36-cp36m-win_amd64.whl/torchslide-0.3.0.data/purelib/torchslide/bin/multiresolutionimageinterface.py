# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_multiresolutionimageinterface')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_multiresolutionimageinterface')
    _multiresolutionimageinterface = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_multiresolutionimageinterface', [dirname(__file__)])
        except ImportError:
            import _multiresolutionimageinterface
            return _multiresolutionimageinterface
        try:
            _mod = imp.load_module('_multiresolutionimageinterface', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _multiresolutionimageinterface = swig_import_helper()
    del swig_import_helper
else:
    import _multiresolutionimageinterface
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _multiresolutionimageinterface.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _multiresolutionimageinterface.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _multiresolutionimageinterface.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _multiresolutionimageinterface.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _multiresolutionimageinterface.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _multiresolutionimageinterface.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _multiresolutionimageinterface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _multiresolutionimageinterface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _multiresolutionimageinterface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _multiresolutionimageinterface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _multiresolutionimageinterface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _multiresolutionimageinterface.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _multiresolutionimageinterface.SHARED_PTR_DISOWN
class vector_int(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_int, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_int___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_int___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _multiresolutionimageinterface.vector_int___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _multiresolutionimageinterface.vector_int___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_int___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _multiresolutionimageinterface.vector_int___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _multiresolutionimageinterface.vector_int_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_int_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_int_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _multiresolutionimageinterface.vector_int_size(self)

    def swap(self, v: 'vector_int') -> "void":
        return _multiresolutionimageinterface.vector_int_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _multiresolutionimageinterface.vector_int_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _multiresolutionimageinterface.vector_int_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _multiresolutionimageinterface.vector_int_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _multiresolutionimageinterface.vector_int_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_int_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _multiresolutionimageinterface.vector_int_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_int_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _multiresolutionimageinterface.vector_int_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_int(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_int_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _multiresolutionimageinterface.vector_int_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _multiresolutionimageinterface.vector_int_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_int_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_int_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _multiresolutionimageinterface.vector_int_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_int
    __del__ = lambda self: None
vector_int_swigregister = _multiresolutionimageinterface.vector_int_swigregister
vector_int_swigregister(vector_int)

class vector_uint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_uint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_uint, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_uint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_uint___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_uint___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _multiresolutionimageinterface.vector_uint___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _multiresolutionimageinterface.vector_uint___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_uint___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _multiresolutionimageinterface.vector_uint___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _multiresolutionimageinterface.vector_uint_pop(self)

    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_uint_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_uint_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _multiresolutionimageinterface.vector_uint_size(self)

    def swap(self, v: 'vector_uint') -> "void":
        return _multiresolutionimageinterface.vector_uint_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _multiresolutionimageinterface.vector_uint_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _multiresolutionimageinterface.vector_uint_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _multiresolutionimageinterface.vector_uint_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _multiresolutionimageinterface.vector_uint_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_uint_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _multiresolutionimageinterface.vector_uint_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_uint_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _multiresolutionimageinterface.vector_uint_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_uint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_uint_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _multiresolutionimageinterface.vector_uint_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _multiresolutionimageinterface.vector_uint_back(self)

    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_uint_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_uint_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _multiresolutionimageinterface.vector_uint_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_uint
    __del__ = lambda self: None
vector_uint_swigregister = _multiresolutionimageinterface.vector_uint_swigregister
vector_uint_swigregister(vector_uint)

class vector_float(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_float, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_float, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_float_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_float___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_float___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _multiresolutionimageinterface.vector_float___len__(self)

    def __getslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "std::vector< float,std::allocator< float > > *":
        return _multiresolutionimageinterface.vector_float___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_float___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _multiresolutionimageinterface.vector_float___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _multiresolutionimageinterface.vector_float_pop(self)

    def append(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_float_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_float_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _multiresolutionimageinterface.vector_float_size(self)

    def swap(self, v: 'vector_float') -> "void":
        return _multiresolutionimageinterface.vector_float_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _multiresolutionimageinterface.vector_float_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _multiresolutionimageinterface.vector_float_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _multiresolutionimageinterface.vector_float_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _multiresolutionimageinterface.vector_float_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_float_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _multiresolutionimageinterface.vector_float_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_float_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _multiresolutionimageinterface.vector_float_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_float_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _multiresolutionimageinterface.vector_float_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _multiresolutionimageinterface.vector_float_back(self)

    def assign(self, n: 'std::vector< float >::size_type', x: 'std::vector< float >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_float_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float_insert(self, *args)

    def reserve(self, n: 'std::vector< float >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_float_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _multiresolutionimageinterface.vector_float_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_float
    __del__ = lambda self: None
vector_float_swigregister = _multiresolutionimageinterface.vector_float_swigregister
vector_float_swigregister(vector_float)

class vector_double(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_double, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_double___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _multiresolutionimageinterface.vector_double___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _multiresolutionimageinterface.vector_double___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_double___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _multiresolutionimageinterface.vector_double___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _multiresolutionimageinterface.vector_double_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_double_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_double_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _multiresolutionimageinterface.vector_double_size(self)

    def swap(self, v: 'vector_double') -> "void":
        return _multiresolutionimageinterface.vector_double_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _multiresolutionimageinterface.vector_double_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _multiresolutionimageinterface.vector_double_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _multiresolutionimageinterface.vector_double_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _multiresolutionimageinterface.vector_double_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_double_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _multiresolutionimageinterface.vector_double_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_double_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _multiresolutionimageinterface.vector_double_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_double_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _multiresolutionimageinterface.vector_double_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _multiresolutionimageinterface.vector_double_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_double_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_double_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _multiresolutionimageinterface.vector_double_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_double
    __del__ = lambda self: None
vector_double_swigregister = _multiresolutionimageinterface.vector_double_swigregister
vector_double_swigregister(vector_double)

class vector_annotation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_annotation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_annotation, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_annotation_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< Annotation > >::size_type":
        return _multiresolutionimageinterface.vector_annotation___len__(self)

    def __getslice__(self, i: 'std::vector< std::shared_ptr< Annotation > >::difference_type', j: 'std::vector< std::shared_ptr< Annotation > >::difference_type') -> "std::vector< std::shared_ptr< Annotation >,std::allocator< std::shared_ptr< Annotation > > > *":
        return _multiresolutionimageinterface.vector_annotation___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::shared_ptr< Annotation > >::difference_type', j: 'std::vector< std::shared_ptr< Annotation > >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_annotation___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< Annotation > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< Annotation > >::value_type":
        return _multiresolutionimageinterface.vector_annotation_pop(self)

    def append(self, x: 'std::vector< std::shared_ptr< Annotation > >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_annotation_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< Annotation > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_size(self)

    def swap(self, v: 'vector_annotation') -> "void":
        return _multiresolutionimageinterface.vector_annotation_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< Annotation > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< Annotation > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< Annotation > >::reverse_iterator":
        return _multiresolutionimageinterface.vector_annotation_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< Annotation > >::reverse_iterator":
        return _multiresolutionimageinterface.vector_annotation_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_annotation_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< Annotation > >::allocator_type":
        return _multiresolutionimageinterface.vector_annotation_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_annotation_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< Annotation > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_annotation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::shared_ptr< Annotation > >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_annotation_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< Annotation > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_front(self)

    def back(self) -> "std::vector< std::shared_ptr< Annotation > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_back(self)

    def assign(self, n: 'std::vector< std::shared_ptr< Annotation > >::size_type', x: 'std::vector< std::shared_ptr< Annotation > >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_annotation_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_insert(self, *args)

    def reserve(self, n: 'std::vector< std::shared_ptr< Annotation > >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_annotation_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< Annotation > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_annotation
    __del__ = lambda self: None
vector_annotation_swigregister = _multiresolutionimageinterface.vector_annotation_swigregister
vector_annotation_swigregister(vector_annotation)

class vector_annotation_group(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_annotation_group, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_annotation_group, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_annotation_group_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation_group___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation_group___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_group___len__(self)

    def __getslice__(self, i: 'std::vector< std::shared_ptr< AnnotationGroup > >::difference_type', j: 'std::vector< std::shared_ptr< AnnotationGroup > >::difference_type') -> "std::vector< std::shared_ptr< AnnotationGroup >,std::allocator< std::shared_ptr< AnnotationGroup > > > *":
        return _multiresolutionimageinterface.vector_annotation_group___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::shared_ptr< AnnotationGroup > >::difference_type', j: 'std::vector< std::shared_ptr< AnnotationGroup > >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_annotation_group___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_group___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::value_type":
        return _multiresolutionimageinterface.vector_annotation_group_pop(self)

    def append(self, x: 'std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation_group_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_group_size(self)

    def swap(self, v: 'vector_annotation_group') -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_group_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_group_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::reverse_iterator":
        return _multiresolutionimageinterface.vector_annotation_group_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::reverse_iterator":
        return _multiresolutionimageinterface.vector_annotation_group_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::allocator_type":
        return _multiresolutionimageinterface.vector_annotation_group_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< AnnotationGroup > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_group_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_annotation_group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_group_front(self)

    def back(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_group_back(self)

    def assign(self, n: 'std::vector< std::shared_ptr< AnnotationGroup > >::size_type', x: 'std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_insert(self, *args)

    def reserve(self, n: 'std::vector< std::shared_ptr< AnnotationGroup > >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_group_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_annotation_group
    __del__ = lambda self: None
vector_annotation_group_swigregister = _multiresolutionimageinterface.vector_annotation_group_swigregister
vector_annotation_group_swigregister(vector_annotation_group)

class vector_unsigned_long_long(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_unsigned_long_long, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_unsigned_long_long, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_unsigned_long_long_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_unsigned_long_long___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_unsigned_long_long___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned long long >::difference_type', j: 'std::vector< unsigned long long >::difference_type') -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        return _multiresolutionimageinterface.vector_unsigned_long_long___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned long long >::difference_type', j: 'std::vector< unsigned long long >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        return _multiresolutionimageinterface.vector_unsigned_long_long___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long_pop(self)

    def append(self, x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_unsigned_long_long_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long_size(self)

    def swap(self, v: 'vector_unsigned_long_long') -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_unsigned_long_long(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        return _multiresolutionimageinterface.vector_unsigned_long_long_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        return _multiresolutionimageinterface.vector_unsigned_long_long_back(self)

    def assign(self, n: 'std::vector< unsigned long long >::size_type', x: 'std::vector< unsigned long long >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned long long >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_unsigned_long_long
    __del__ = lambda self: None
vector_unsigned_long_long_swigregister = _multiresolutionimageinterface.vector_unsigned_long_long_swigregister
vector_unsigned_long_long_swigregister(vector_unsigned_long_long)

class vector_long_long(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_long_long, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_long_long, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_long_long_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_long_long___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_long_long___bool__(self)

    def __len__(self) -> "std::vector< long long >::size_type":
        return _multiresolutionimageinterface.vector_long_long___len__(self)

    def __getslice__(self, i: 'std::vector< long long >::difference_type', j: 'std::vector< long long >::difference_type') -> "std::vector< long long,std::allocator< long long > > *":
        return _multiresolutionimageinterface.vector_long_long___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< long long >::difference_type', j: 'std::vector< long long >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_long_long___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long long >::value_type const &":
        return _multiresolutionimageinterface.vector_long_long___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long___setitem__(self, *args)

    def pop(self) -> "std::vector< long long >::value_type":
        return _multiresolutionimageinterface.vector_long_long_pop(self)

    def append(self, x: 'std::vector< long long >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_long_long_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_long_long_empty(self)

    def size(self) -> "std::vector< long long >::size_type":
        return _multiresolutionimageinterface.vector_long_long_size(self)

    def swap(self, v: 'vector_long_long') -> "void":
        return _multiresolutionimageinterface.vector_long_long_swap(self, v)

    def begin(self) -> "std::vector< long long >::iterator":
        return _multiresolutionimageinterface.vector_long_long_begin(self)

    def end(self) -> "std::vector< long long >::iterator":
        return _multiresolutionimageinterface.vector_long_long_end(self)

    def rbegin(self) -> "std::vector< long long >::reverse_iterator":
        return _multiresolutionimageinterface.vector_long_long_rbegin(self)

    def rend(self) -> "std::vector< long long >::reverse_iterator":
        return _multiresolutionimageinterface.vector_long_long_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_long_long_clear(self)

    def get_allocator(self) -> "std::vector< long long >::allocator_type":
        return _multiresolutionimageinterface.vector_long_long_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_long_long_pop_back(self)

    def erase(self, *args) -> "std::vector< long long >::iterator":
        return _multiresolutionimageinterface.vector_long_long_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_long_long(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< long long >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_long_long_push_back(self, x)

    def front(self) -> "std::vector< long long >::value_type const &":
        return _multiresolutionimageinterface.vector_long_long_front(self)

    def back(self) -> "std::vector< long long >::value_type const &":
        return _multiresolutionimageinterface.vector_long_long_back(self)

    def assign(self, n: 'std::vector< long long >::size_type', x: 'std::vector< long long >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_long_long_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long_insert(self, *args)

    def reserve(self, n: 'std::vector< long long >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_long_long_reserve(self, n)

    def capacity(self) -> "std::vector< long long >::size_type":
        return _multiresolutionimageinterface.vector_long_long_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_long_long
    __del__ = lambda self: None
vector_long_long_swigregister = _multiresolutionimageinterface.vector_long_long_swigregister
vector_long_long_swigregister(vector_long_long)

class vector_string(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_string, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_string, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_string___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _multiresolutionimageinterface.vector_string___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _multiresolutionimageinterface.vector_string___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_string___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _multiresolutionimageinterface.vector_string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _multiresolutionimageinterface.vector_string_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_string_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_string_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _multiresolutionimageinterface.vector_string_size(self)

    def swap(self, v: 'vector_string') -> "void":
        return _multiresolutionimageinterface.vector_string_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _multiresolutionimageinterface.vector_string_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _multiresolutionimageinterface.vector_string_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _multiresolutionimageinterface.vector_string_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _multiresolutionimageinterface.vector_string_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_string_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _multiresolutionimageinterface.vector_string_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_string_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _multiresolutionimageinterface.vector_string_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_string(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_string_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _multiresolutionimageinterface.vector_string_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _multiresolutionimageinterface.vector_string_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _multiresolutionimageinterface.vector_string_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_string_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _multiresolutionimageinterface.vector_string_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_string
    __del__ = lambda self: None
vector_string_swigregister = _multiresolutionimageinterface.vector_string_swigregister
vector_string_swigregister(vector_string)

class vector_point(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_point, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_point, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_point_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_point___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_point___bool__(self)

    def __len__(self) -> "std::vector< Point >::size_type":
        return _multiresolutionimageinterface.vector_point___len__(self)

    def __getslice__(self, i: 'std::vector< Point >::difference_type', j: 'std::vector< Point >::difference_type') -> "std::vector< Point,std::allocator< Point > > *":
        return _multiresolutionimageinterface.vector_point___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< Point >::difference_type', j: 'std::vector< Point >::difference_type') -> "void":
        return _multiresolutionimageinterface.vector_point___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Point >::value_type const &":
        return _multiresolutionimageinterface.vector_point___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point___setitem__(self, *args)

    def pop(self) -> "std::vector< Point >::value_type":
        return _multiresolutionimageinterface.vector_point_pop(self)

    def append(self, x: 'Point') -> "void":
        return _multiresolutionimageinterface.vector_point_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_point_empty(self)

    def size(self) -> "std::vector< Point >::size_type":
        return _multiresolutionimageinterface.vector_point_size(self)

    def swap(self, v: 'vector_point') -> "void":
        return _multiresolutionimageinterface.vector_point_swap(self, v)

    def begin(self) -> "std::vector< Point >::iterator":
        return _multiresolutionimageinterface.vector_point_begin(self)

    def end(self) -> "std::vector< Point >::iterator":
        return _multiresolutionimageinterface.vector_point_end(self)

    def rbegin(self) -> "std::vector< Point >::reverse_iterator":
        return _multiresolutionimageinterface.vector_point_rbegin(self)

    def rend(self) -> "std::vector< Point >::reverse_iterator":
        return _multiresolutionimageinterface.vector_point_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_point_clear(self)

    def get_allocator(self) -> "std::vector< Point >::allocator_type":
        return _multiresolutionimageinterface.vector_point_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_point_pop_back(self)

    def erase(self, *args) -> "std::vector< Point >::iterator":
        return _multiresolutionimageinterface.vector_point_erase(self, *args)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_vector_point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'Point') -> "void":
        return _multiresolutionimageinterface.vector_point_push_back(self, x)

    def front(self) -> "std::vector< Point >::value_type const &":
        return _multiresolutionimageinterface.vector_point_front(self)

    def back(self) -> "std::vector< Point >::value_type const &":
        return _multiresolutionimageinterface.vector_point_back(self)

    def assign(self, n: 'std::vector< Point >::size_type', x: 'Point') -> "void":
        return _multiresolutionimageinterface.vector_point_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point_insert(self, *args)

    def reserve(self, n: 'std::vector< Point >::size_type') -> "void":
        return _multiresolutionimageinterface.vector_point_reserve(self, n)

    def capacity(self) -> "std::vector< Point >::size_type":
        return _multiresolutionimageinterface.vector_point_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_point
    __del__ = lambda self: None
vector_point_swigregister = _multiresolutionimageinterface.vector_point_swigregister
vector_point_swigregister(vector_point)

class map_int_string(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, map_int_string, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, map_int_string, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_int_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.map_int_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.map_int_string___bool__(self)

    def __len__(self) -> "std::map< int,std::string >::size_type":
        return _multiresolutionimageinterface.map_int_string___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< int,std::string >::key_type const &') -> "std::map< int,std::string >::mapped_type const &":
        return _multiresolutionimageinterface.map_int_string___getitem__(self, key)

    def __delitem__(self, key: 'std::map< int,std::string >::key_type const &') -> "void":
        return _multiresolutionimageinterface.map_int_string___delitem__(self, key)

    def has_key(self, key: 'std::map< int,std::string >::key_type const &') -> "bool":
        return _multiresolutionimageinterface.map_int_string_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_int_string_keys(self)

    def values(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_int_string_values(self)

    def items(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_int_string_items(self)

    def __contains__(self, key: 'std::map< int,std::string >::key_type const &') -> "bool":
        return _multiresolutionimageinterface.map_int_string___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_int_string_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_int_string_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.map_int_string___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_int_string_asdict(self)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_map_int_string(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.map_int_string_empty(self)

    def size(self) -> "std::map< int,std::string >::size_type":
        return _multiresolutionimageinterface.map_int_string_size(self)

    def swap(self, v: 'map_int_string') -> "void":
        return _multiresolutionimageinterface.map_int_string_swap(self, v)

    def begin(self) -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_begin(self)

    def end(self) -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_end(self)

    def rbegin(self) -> "std::map< int,std::string >::reverse_iterator":
        return _multiresolutionimageinterface.map_int_string_rbegin(self)

    def rend(self) -> "std::map< int,std::string >::reverse_iterator":
        return _multiresolutionimageinterface.map_int_string_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.map_int_string_clear(self)

    def get_allocator(self) -> "std::map< int,std::string >::allocator_type":
        return _multiresolutionimageinterface.map_int_string_get_allocator(self)

    def count(self, x: 'std::map< int,std::string >::key_type const &') -> "std::map< int,std::string >::size_type":
        return _multiresolutionimageinterface.map_int_string_count(self, x)

    def erase(self, *args) -> "void":
        return _multiresolutionimageinterface.map_int_string_erase(self, *args)

    def find(self, x: 'std::map< int,std::string >::key_type const &') -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_find(self, x)

    def lower_bound(self, x: 'std::map< int,std::string >::key_type const &') -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< int,std::string >::key_type const &') -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_upper_bound(self, x)
    __swig_destroy__ = _multiresolutionimageinterface.delete_map_int_string
    __del__ = lambda self: None
map_int_string_swigregister = _multiresolutionimageinterface.map_int_string_swigregister
map_int_string_swigregister(map_int_string)

class map_string_int(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, map_string_int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, map_string_int, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_string_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.map_string_int___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.map_string_int___bool__(self)

    def __len__(self) -> "std::map< std::string,int >::size_type":
        return _multiresolutionimageinterface.map_string_int___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,int >::key_type const &') -> "std::map< std::string,int >::mapped_type const &":
        return _multiresolutionimageinterface.map_string_int___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,int >::key_type const &') -> "void":
        return _multiresolutionimageinterface.map_string_int___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,int >::key_type const &') -> "bool":
        return _multiresolutionimageinterface.map_string_int_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_string_int_keys(self)

    def values(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_string_int_values(self)

    def items(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_string_int_items(self)

    def __contains__(self, key: 'std::map< std::string,int >::key_type const &') -> "bool":
        return _multiresolutionimageinterface.map_string_int___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_string_int_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_string_int_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.map_string_int___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_string_int_asdict(self)

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_map_string_int(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.map_string_int_empty(self)

    def size(self) -> "std::map< std::string,int >::size_type":
        return _multiresolutionimageinterface.map_string_int_size(self)

    def swap(self, v: 'map_string_int') -> "void":
        return _multiresolutionimageinterface.map_string_int_swap(self, v)

    def begin(self) -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_begin(self)

    def end(self) -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_end(self)

    def rbegin(self) -> "std::map< std::string,int >::reverse_iterator":
        return _multiresolutionimageinterface.map_string_int_rbegin(self)

    def rend(self) -> "std::map< std::string,int >::reverse_iterator":
        return _multiresolutionimageinterface.map_string_int_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.map_string_int_clear(self)

    def get_allocator(self) -> "std::map< std::string,int >::allocator_type":
        return _multiresolutionimageinterface.map_string_int_get_allocator(self)

    def count(self, x: 'std::map< std::string,int >::key_type const &') -> "std::map< std::string,int >::size_type":
        return _multiresolutionimageinterface.map_string_int_count(self, x)

    def erase(self, *args) -> "void":
        return _multiresolutionimageinterface.map_string_int_erase(self, *args)

    def find(self, x: 'std::map< std::string,int >::key_type const &') -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,int >::key_type const &') -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,int >::key_type const &') -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_upper_bound(self, x)
    __swig_destroy__ = _multiresolutionimageinterface.delete_map_string_int
    __del__ = lambda self: None
map_string_int_swigregister = _multiresolutionimageinterface.map_string_int_swigregister
map_string_int_swigregister(map_string_int)

ASAP_MAJOR_VERSION = _multiresolutionimageinterface.ASAP_MAJOR_VERSION
ASAP_MINOR_VERSION = _multiresolutionimageinterface.ASAP_MINOR_VERSION
ASAP_PATCH_VERSION = _multiresolutionimageinterface.ASAP_PATCH_VERSION
class Point(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Point, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _multiresolutionimageinterface.new_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getX(self) -> "float":
        return _multiresolutionimageinterface.Point_getX(self)

    def getY(self) -> "float":
        return _multiresolutionimageinterface.Point_getY(self)

    def setX(self, x: 'float const &') -> "void":
        return _multiresolutionimageinterface.Point_setX(self, x)

    def setY(self, y: 'float const &') -> "void":
        return _multiresolutionimageinterface.Point_setY(self, y)
    __swig_destroy__ = _multiresolutionimageinterface.delete_Point
    __del__ = lambda self: None
Point_swigregister = _multiresolutionimageinterface.Point_swigregister
Point_swigregister(Point)
cvar = _multiresolutionimageinterface.cvar
ASAP_VERSION_STRING = cvar.ASAP_VERSION_STRING

class LUT(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LUT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LUT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["colors"] = _multiresolutionimageinterface.LUT_colors_set
    __swig_getmethods__["colors"] = _multiresolutionimageinterface.LUT_colors_get
    if _newclass:
        colors = _swig_property(_multiresolutionimageinterface.LUT_colors_get, _multiresolutionimageinterface.LUT_colors_set)
    __swig_setmethods__["wrapAround"] = _multiresolutionimageinterface.LUT_wrapAround_set
    __swig_getmethods__["wrapAround"] = _multiresolutionimageinterface.LUT_wrapAround_get
    if _newclass:
        wrapAround = _swig_property(_multiresolutionimageinterface.LUT_wrapAround_get, _multiresolutionimageinterface.LUT_wrapAround_set)

    def __init__(self):
        this = _multiresolutionimageinterface.new_LUT()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_LUT
    __del__ = lambda self: None
LUT_swigregister = _multiresolutionimageinterface.LUT_swigregister
LUT_swigregister(LUT)

InvalidColorType = _multiresolutionimageinterface.InvalidColorType
Monochrome = _multiresolutionimageinterface.Monochrome
RGB = _multiresolutionimageinterface.RGB
ARGB = _multiresolutionimageinterface.ARGB
Indexed = _multiresolutionimageinterface.Indexed
InvalidDataType = _multiresolutionimageinterface.InvalidDataType
UChar = _multiresolutionimageinterface.UChar
UInt16 = _multiresolutionimageinterface.UInt16
UInt32 = _multiresolutionimageinterface.UInt32
Float = _multiresolutionimageinterface.Float
RAW = _multiresolutionimageinterface.RAW
JPEG = _multiresolutionimageinterface.JPEG
LZW = _multiresolutionimageinterface.LZW
JPEG2000 = _multiresolutionimageinterface.JPEG2000
NearestNeighbor = _multiresolutionimageinterface.NearestNeighbor
Linear = _multiresolutionimageinterface.Linear
class ImageSource(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageSource, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ImageSource, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_ImageSource
    __del__ = lambda self: None

    def valid(self) -> "bool":
        return _multiresolutionimageinterface.ImageSource_valid(self)

    def getDimensions(self) -> "std::vector< unsigned long long,std::allocator< unsigned long long > > const":
        return _multiresolutionimageinterface.ImageSource_getDimensions(self)

    def getColorType(self) -> "pathology::ColorType const":
        return _multiresolutionimageinterface.ImageSource_getColorType(self)

    def getDataType(self) -> "pathology::DataType const":
        return _multiresolutionimageinterface.ImageSource_getDataType(self)

    def getSamplesPerPixel(self) -> "int const":
        return _multiresolutionimageinterface.ImageSource_getSamplesPerPixel(self)

    def getSpacing(self) -> "std::vector< double,std::allocator< double > > const":
        return _multiresolutionimageinterface.ImageSource_getSpacing(self)

    def getMinValue(self, channel: 'int'=-1) -> "double":
        return _multiresolutionimageinterface.ImageSource_getMinValue(self, channel)

    def getMaxValue(self, channel: 'int'=-1) -> "double":
        return _multiresolutionimageinterface.ImageSource_getMaxValue(self, channel)
ImageSource_swigregister = _multiresolutionimageinterface.ImageSource_swigregister
ImageSource_swigregister(ImageSource)
ColorLookupTables = cvar.ColorLookupTables

class CmdLineProgressMonitor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CmdLineProgressMonitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CmdLineProgressMonitor, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _multiresolutionimageinterface.new_CmdLineProgressMonitor()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_CmdLineProgressMonitor
    __del__ = lambda self: None

    def setProgress(self, progress: 'unsigned int const &') -> "void":
        return _multiresolutionimageinterface.CmdLineProgressMonitor_setProgress(self, progress)

    def setStatus(self, status: 'std::string const &') -> "void":
        return _multiresolutionimageinterface.CmdLineProgressMonitor_setStatus(self, status)
CmdLineProgressMonitor_swigregister = _multiresolutionimageinterface.CmdLineProgressMonitor_swigregister
CmdLineProgressMonitor_swigregister(CmdLineProgressMonitor)

class AnnotationBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnnotationBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AnnotationBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationBase
    __del__ = lambda self: None

    def setName(self, name: 'std::string const &') -> "void":
        return _multiresolutionimageinterface.AnnotationBase_setName(self, name)

    def getName(self) -> "std::string":
        return _multiresolutionimageinterface.AnnotationBase_getName(self)

    def setGroup(self, group: 'std::shared_ptr< AnnotationGroup > const &') -> "void":
        return _multiresolutionimageinterface.AnnotationBase_setGroup(self, group)

    def getGroup(self) -> "std::shared_ptr< AnnotationGroup >":
        return _multiresolutionimageinterface.AnnotationBase_getGroup(self)

    def getColor(self) -> "std::string":
        return _multiresolutionimageinterface.AnnotationBase_getColor(self)

    def setColor(self, color: 'std::string const &') -> "void":
        return _multiresolutionimageinterface.AnnotationBase_setColor(self, color)

    def getImageBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.AnnotationBase_getImageBoundingBox(self)

    def getLocalBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.AnnotationBase_getLocalBoundingBox(self)

    def getCenter(self) -> "Point":
        return _multiresolutionimageinterface.AnnotationBase_getCenter(self)

    def getArea(self) -> "float":
        return _multiresolutionimageinterface.AnnotationBase_getArea(self)

    def getNumberOfPoints(self) -> "unsigned int":
        return _multiresolutionimageinterface.AnnotationBase_getNumberOfPoints(self)

    def isModified(self) -> "bool":
        return _multiresolutionimageinterface.AnnotationBase_isModified(self)

    def resetModifiedStatus(self) -> "void":
        return _multiresolutionimageinterface.AnnotationBase_resetModifiedStatus(self)
AnnotationBase_swigregister = _multiresolutionimageinterface.AnnotationBase_swigregister
AnnotationBase_swigregister(AnnotationBase)

class Annotation(AnnotationBase):
    __swig_setmethods__ = {}
    for _s in [AnnotationBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Annotation, name, value)
    __swig_getmethods__ = {}
    for _s in [AnnotationBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Annotation, name)
    __repr__ = _swig_repr
    NONE = _multiresolutionimageinterface.Annotation_NONE
    DOT = _multiresolutionimageinterface.Annotation_DOT
    POLYGON = _multiresolutionimageinterface.Annotation_POLYGON
    SPLINE = _multiresolutionimageinterface.Annotation_SPLINE
    POINTSET = _multiresolutionimageinterface.Annotation_POINTSET
    MEASUREMENT = _multiresolutionimageinterface.Annotation_MEASUREMENT
    RECTANGLE = _multiresolutionimageinterface.Annotation_RECTANGLE

    def __init__(self):
        this = _multiresolutionimageinterface.new_Annotation()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addCoordinate(self, *args) -> "void":
        return _multiresolutionimageinterface.Annotation_addCoordinate(self, *args)

    def insertCoordinate(self, *args) -> "void":
        return _multiresolutionimageinterface.Annotation_insertCoordinate(self, *args)

    def removeCoordinate(self, index: 'int const &') -> "void":
        return _multiresolutionimageinterface.Annotation_removeCoordinate(self, index)

    def setCoordinates(self, coordinates: 'vector_point') -> "void":
        return _multiresolutionimageinterface.Annotation_setCoordinates(self, coordinates)

    def getCoordinate(self, index: 'int const &') -> "Point":
        return _multiresolutionimageinterface.Annotation_getCoordinate(self, index)

    def getCoordinates(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.Annotation_getCoordinates(self)

    def clearCoordinates(self) -> "void":
        return _multiresolutionimageinterface.Annotation_clearCoordinates(self)

    def setType(self, type: 'Annotation::Type const &') -> "void":
        return _multiresolutionimageinterface.Annotation_setType(self, type)

    def getType(self) -> "Annotation::Type":
        return _multiresolutionimageinterface.Annotation_getType(self)

    def getTypeAsString(self) -> "std::string":
        return _multiresolutionimageinterface.Annotation_getTypeAsString(self)

    def setTypeFromString(self, type: 'std::string const &') -> "void":
        return _multiresolutionimageinterface.Annotation_setTypeFromString(self, type)

    def getImageBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.Annotation_getImageBoundingBox(self)

    def getLocalBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.Annotation_getLocalBoundingBox(self)

    def getCenter(self) -> "Point":
        return _multiresolutionimageinterface.Annotation_getCenter(self)

    def simplify(self, nrPoints: 'unsigned int'=0, epsilon: 'float'=1.0) -> "void":
        return _multiresolutionimageinterface.Annotation_simplify(self, nrPoints, epsilon)

    def getArea(self) -> "float":
        return _multiresolutionimageinterface.Annotation_getArea(self)

    def getNumberOfPoints(self) -> "unsigned int":
        return _multiresolutionimageinterface.Annotation_getNumberOfPoints(self)

    def isClockwise(self) -> "bool":
        return _multiresolutionimageinterface.Annotation_isClockwise(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_Annotation
    __del__ = lambda self: None
Annotation_swigregister = _multiresolutionimageinterface.Annotation_swigregister
Annotation_swigregister(Annotation)

class AnnotationGroup(AnnotationBase):
    __swig_setmethods__ = {}
    for _s in [AnnotationBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnnotationGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [AnnotationBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AnnotationGroup, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _multiresolutionimageinterface.new_AnnotationGroup()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationGroup
    __del__ = lambda self: None

    def getImageBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.AnnotationGroup_getImageBoundingBox(self)

    def getLocalBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.AnnotationGroup_getLocalBoundingBox(self)

    def getCenter(self) -> "Point":
        return _multiresolutionimageinterface.AnnotationGroup_getCenter(self)

    def getArea(self) -> "float":
        return _multiresolutionimageinterface.AnnotationGroup_getArea(self)

    def getNumberOfPoints(self) -> "unsigned int":
        return _multiresolutionimageinterface.AnnotationGroup_getNumberOfPoints(self)

    def clearAttributes(self) -> "void":
        return _multiresolutionimageinterface.AnnotationGroup_clearAttributes(self)

    def getAttributes(self) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        return _multiresolutionimageinterface.AnnotationGroup_getAttributes(self)

    def setAttributes(self, attributes: 'std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >') -> "void":
        return _multiresolutionimageinterface.AnnotationGroup_setAttributes(self, attributes)

    def addMember(self, member: 'std::shared_ptr< AnnotationBase >') -> "void":
        return _multiresolutionimageinterface.AnnotationGroup_addMember(self, member)

    def removeMember(self, member: 'std::shared_ptr< AnnotationBase >') -> "void":
        return _multiresolutionimageinterface.AnnotationGroup_removeMember(self, member)
AnnotationGroup_swigregister = _multiresolutionimageinterface.AnnotationGroup_swigregister
AnnotationGroup_swigregister(AnnotationGroup)

class AnnotationList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnnotationList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AnnotationList, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _multiresolutionimageinterface.new_AnnotationList()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationList
    __del__ = lambda self: None

    def isModified(self) -> "bool":
        return _multiresolutionimageinterface.AnnotationList_isModified(self)

    def resetModifiedStatus(self) -> "void":
        return _multiresolutionimageinterface.AnnotationList_resetModifiedStatus(self)

    def addGroup(self, group: 'std::shared_ptr< AnnotationGroup > const &') -> "bool":
        return _multiresolutionimageinterface.AnnotationList_addGroup(self, group)

    def addAnnotation(self, annotation: 'std::shared_ptr< Annotation > const &') -> "bool":
        return _multiresolutionimageinterface.AnnotationList_addAnnotation(self, annotation)

    def getGroup(self, *args) -> "std::shared_ptr< AnnotationGroup >":
        return _multiresolutionimageinterface.AnnotationList_getGroup(self, *args)

    def getAnnotation(self, *args) -> "std::shared_ptr< Annotation >":
        return _multiresolutionimageinterface.AnnotationList_getAnnotation(self, *args)

    def getAnnotations(self) -> "std::vector< std::shared_ptr< Annotation >,std::allocator< std::shared_ptr< Annotation > > >":
        return _multiresolutionimageinterface.AnnotationList_getAnnotations(self)

    def getGroups(self) -> "std::vector< std::shared_ptr< AnnotationGroup >,std::allocator< std::shared_ptr< AnnotationGroup > > >":
        return _multiresolutionimageinterface.AnnotationList_getGroups(self)

    def setAnnotations(self, annotations: 'vector_annotation') -> "void":
        return _multiresolutionimageinterface.AnnotationList_setAnnotations(self, annotations)

    def setGroups(self, groups: 'vector_annotation_group') -> "void":
        return _multiresolutionimageinterface.AnnotationList_setGroups(self, groups)

    def removeGroup(self, *args) -> "void":
        return _multiresolutionimageinterface.AnnotationList_removeGroup(self, *args)

    def removeAnnotation(self, *args) -> "void":
        return _multiresolutionimageinterface.AnnotationList_removeAnnotation(self, *args)

    def removeAllAnnotations(self) -> "void":
        return _multiresolutionimageinterface.AnnotationList_removeAllAnnotations(self)

    def removeAllGroups(self) -> "void":
        return _multiresolutionimageinterface.AnnotationList_removeAllGroups(self)
AnnotationList_swigregister = _multiresolutionimageinterface.AnnotationList_swigregister
AnnotationList_swigregister(AnnotationList)

class AnnotationService(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnnotationService, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AnnotationService, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _multiresolutionimageinterface.new_AnnotationService()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationService
    __del__ = lambda self: None

    def getList(self) -> "std::shared_ptr< AnnotationList >":
        return _multiresolutionimageinterface.AnnotationService_getList(self)

    def getRepository(self) -> "std::shared_ptr< Repository >":
        return _multiresolutionimageinterface.AnnotationService_getRepository(self)

    def loadRepositoryFromFile(self, source: 'std::string const &') -> "bool":
        return _multiresolutionimageinterface.AnnotationService_loadRepositoryFromFile(self, source)

    def saveRepositoryToFile(self, source: 'std::string const &') -> "bool":
        return _multiresolutionimageinterface.AnnotationService_saveRepositoryToFile(self, source)
AnnotationService_swigregister = _multiresolutionimageinterface.AnnotationService_swigregister
AnnotationService_swigregister(AnnotationService)

class AnnotationToMask(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnnotationToMask, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AnnotationToMask, name)
    __repr__ = _swig_repr

    def convert(self, *args) -> "void":
        return _multiresolutionimageinterface.AnnotationToMask_convert(self, *args)

    def setProgressMonitor(self, monitor: 'ProgressMonitor *') -> "void":
        return _multiresolutionimageinterface.AnnotationToMask_setProgressMonitor(self, monitor)

    def __init__(self):
        this = _multiresolutionimageinterface.new_AnnotationToMask()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationToMask
    __del__ = lambda self: None
AnnotationToMask_swigregister = _multiresolutionimageinterface.AnnotationToMask_swigregister
AnnotationToMask_swigregister(AnnotationToMask)

class Repository(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Repository, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Repository, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_Repository
    __del__ = lambda self: None

    def setSource(self, sourcePath: 'std::string const &') -> "void":
        return _multiresolutionimageinterface.Repository_setSource(self, sourcePath)

    def load(self) -> "bool":
        return _multiresolutionimageinterface.Repository_load(self)

    def save(self) -> "bool":
        return _multiresolutionimageinterface.Repository_save(self)
Repository_swigregister = _multiresolutionimageinterface.Repository_swigregister
Repository_swigregister(Repository)

class XmlRepository(Repository):
    __swig_setmethods__ = {}
    for _s in [Repository]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XmlRepository, name, value)
    __swig_getmethods__ = {}
    for _s in [Repository]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, XmlRepository, name)
    __repr__ = _swig_repr

    def __init__(self, list: 'std::shared_ptr< AnnotationList > const &'):
        this = _multiresolutionimageinterface.new_XmlRepository(list)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def save(self) -> "bool":
        return _multiresolutionimageinterface.XmlRepository_save(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_XmlRepository
    __del__ = lambda self: None
XmlRepository_swigregister = _multiresolutionimageinterface.XmlRepository_swigregister
XmlRepository_swigregister(XmlRepository)

class NDPARepository(Repository):
    __swig_setmethods__ = {}
    for _s in [Repository]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NDPARepository, name, value)
    __swig_getmethods__ = {}
    for _s in [Repository]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NDPARepository, name)
    __repr__ = _swig_repr

    def __init__(self, list: 'std::shared_ptr< AnnotationList > const &'):
        this = _multiresolutionimageinterface.new_NDPARepository(list)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setNDPISourceFile(self, ndpiSourcefile: 'std::string const &') -> "void":
        return _multiresolutionimageinterface.NDPARepository_setNDPISourceFile(self, ndpiSourcefile)

    def NDPISourceFile(self) -> "std::string":
        return _multiresolutionimageinterface.NDPARepository_NDPISourceFile(self)

    def save(self) -> "bool":
        return _multiresolutionimageinterface.NDPARepository_save(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_NDPARepository
    __del__ = lambda self: None
NDPARepository_swigregister = _multiresolutionimageinterface.NDPARepository_swigregister
NDPARepository_swigregister(NDPARepository)

class ImageScopeRepository(Repository):
    __swig_setmethods__ = {}
    for _s in [Repository]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageScopeRepository, name, value)
    __swig_getmethods__ = {}
    for _s in [Repository]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageScopeRepository, name)
    __repr__ = _swig_repr

    def __init__(self, list: 'std::shared_ptr< AnnotationList > const &'):
        this = _multiresolutionimageinterface.new_ImageScopeRepository(list)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def save(self) -> "bool":
        return _multiresolutionimageinterface.ImageScopeRepository_save(self)

    def setClosingDistance(self, closingDistance: 'float const &') -> "void":
        return _multiresolutionimageinterface.ImageScopeRepository_setClosingDistance(self, closingDistance)

    def getClosingDistance(self) -> "float":
        return _multiresolutionimageinterface.ImageScopeRepository_getClosingDistance(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_ImageScopeRepository
    __del__ = lambda self: None
ImageScopeRepository_swigregister = _multiresolutionimageinterface.ImageScopeRepository_swigregister
ImageScopeRepository_swigregister(ImageScopeRepository)

class MultiResolutionImage(ImageSource):
    __swig_setmethods__ = {}
    for _s in [ImageSource]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiResolutionImage, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageSource]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiResolutionImage, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_MultiResolutionImage
    __del__ = lambda self: None

    def initialize(self, imagePath: 'std::string const &') -> "bool":
        return _multiresolutionimageinterface.MultiResolutionImage_initialize(self, imagePath)

    def initializeType(self, imagePath: 'std::string const &') -> "bool":
        return _multiresolutionimageinterface.MultiResolutionImage_initializeType(self, imagePath)

    def getNumberOfZPlanes(self) -> "int":
        return _multiresolutionimageinterface.MultiResolutionImage_getNumberOfZPlanes(self)

    def setCurrentZPlaneIndex(self, zPlaneIndex: 'unsigned int const &') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImage_setCurrentZPlaneIndex(self, zPlaneIndex)

    def getCurrentZPlaneIndex(self) -> "unsigned int":
        return _multiresolutionimageinterface.MultiResolutionImage_getCurrentZPlaneIndex(self)

    def getProperty(self, propertyName: 'std::string const &') -> "std::string":
        return _multiresolutionimageinterface.MultiResolutionImage_getProperty(self, propertyName)

    def getCacheSize(self) -> "unsigned long long const":
        return _multiresolutionimageinterface.MultiResolutionImage_getCacheSize(self)

    def setCacheSize(self, cacheSize: 'unsigned long long const') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImage_setCacheSize(self, cacheSize)

    def getNumberOfLevels(self) -> "int const":
        return _multiresolutionimageinterface.MultiResolutionImage_getNumberOfLevels(self)

    def getDimensions(self) -> "std::vector< unsigned long long,std::allocator< unsigned long long > > const":
        return _multiresolutionimageinterface.MultiResolutionImage_getDimensions(self)

    def getLevelDimensions(self, level: 'unsigned int const &') -> "std::vector< unsigned long long,std::allocator< unsigned long long > > const":
        return _multiresolutionimageinterface.MultiResolutionImage_getLevelDimensions(self, level)

    def getLevelDownsample(self, level: 'unsigned int const &') -> "double const":
        return _multiresolutionimageinterface.MultiResolutionImage_getLevelDownsample(self, level)

    def getBestLevelForDownSample(self, downsample: 'double const &') -> "int const":
        return _multiresolutionimageinterface.MultiResolutionImage_getBestLevelForDownSample(self, downsample)

    def getMinValue(self, channel: 'int'=-1) -> "double":
        return _multiresolutionimageinterface.MultiResolutionImage_getMinValue(self, channel)

    def getMaxValue(self, channel: 'int'=-1) -> "double":
        return _multiresolutionimageinterface.MultiResolutionImage_getMaxValue(self, channel)

    def getFileType(self) -> "std::string const":
        return _multiresolutionimageinterface.MultiResolutionImage_getFileType(self)

    def close(self) -> "void":
        return _multiresolutionimageinterface.MultiResolutionImage_close(self)

    def getUCharPatch(self, startX: 'long long const &', startY: 'long long const &', width: 'unsigned long long const &', height: 'unsigned long long const &', level: 'unsigned int const &') -> "PyObject *":
        return _multiresolutionimageinterface.MultiResolutionImage_getUCharPatch(self, startX, startY, width, height, level)

    def getUInt16Patch(self, startX: 'long long const &', startY: 'long long const &', width: 'unsigned long long const &', height: 'unsigned long long const &', level: 'unsigned int const &') -> "PyObject *":
        return _multiresolutionimageinterface.MultiResolutionImage_getUInt16Patch(self, startX, startY, width, height, level)

    def getUInt32Patch(self, startX: 'long long const &', startY: 'long long const &', width: 'unsigned long long const &', height: 'unsigned long long const &', level: 'unsigned int const &') -> "PyObject *":
        return _multiresolutionimageinterface.MultiResolutionImage_getUInt32Patch(self, startX, startY, width, height, level)

    def getFloatPatch(self, startX: 'long long const &', startY: 'long long const &', width: 'unsigned long long const &', height: 'unsigned long long const &', level: 'unsigned int const &') -> "PyObject *":
        return _multiresolutionimageinterface.MultiResolutionImage_getFloatPatch(self, startX, startY, width, height, level)
MultiResolutionImage_swigregister = _multiresolutionimageinterface.MultiResolutionImage_swigregister
MultiResolutionImage_swigregister(MultiResolutionImage)

class TIFFImage(MultiResolutionImage):
    __swig_setmethods__ = {}
    for _s in [MultiResolutionImage]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TIFFImage, name, value)
    __swig_getmethods__ = {}
    for _s in [MultiResolutionImage]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TIFFImage, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _multiresolutionimageinterface.new_TIFFImage()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_TIFFImage
    __del__ = lambda self: None

    def initializeType(self, imagePath: 'std::string const &') -> "bool":
        return _multiresolutionimageinterface.TIFFImage_initializeType(self, imagePath)

    def getMinValue(self, channel: 'int'=-1) -> "double":
        return _multiresolutionimageinterface.TIFFImage_getMinValue(self, channel)

    def getMaxValue(self, channel: 'int'=-1) -> "double":
        return _multiresolutionimageinterface.TIFFImage_getMaxValue(self, channel)

    def getEncodedTileSize(self, startX: 'long long const &', startY: 'long long const &', level: 'unsigned int const &') -> "long long":
        return _multiresolutionimageinterface.TIFFImage_getEncodedTileSize(self, startX, startY, level)

    def readEncodedDataFromImage(self, startX: 'long long const &', startY: 'long long const &', level: 'unsigned int const &') -> "unsigned char *":
        return _multiresolutionimageinterface.TIFFImage_readEncodedDataFromImage(self, startX, startY, level)

    def getEncodedTile(self, startX: 'long long const &', startY: 'long long const &', level: 'unsigned int const &') -> "PyObject *":
        return _multiresolutionimageinterface.TIFFImage_getEncodedTile(self, startX, startY, level)
TIFFImage_swigregister = _multiresolutionimageinterface.TIFFImage_swigregister
TIFFImage_swigregister(TIFFImage)


def MultiResolutionImageToTIFFImage(base: 'std::shared_ptr< MultiResolutionImage >') -> "std::shared_ptr< TIFFImage >":
    return _multiresolutionimageinterface.MultiResolutionImageToTIFFImage(base)
MultiResolutionImageToTIFFImage = _multiresolutionimageinterface.MultiResolutionImageToTIFFImage
class MultiResolutionImageReader(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiResolutionImageReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MultiResolutionImageReader, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _multiresolutionimageinterface.new_MultiResolutionImageReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_MultiResolutionImageReader
    __del__ = lambda self: None

    def open(self, *args) -> "MultiResolutionImage *":
        return _multiresolutionimageinterface.MultiResolutionImageReader_open(self, *args)
MultiResolutionImageReader_swigregister = _multiresolutionimageinterface.MultiResolutionImageReader_swigregister
MultiResolutionImageReader_swigregister(MultiResolutionImageReader)

class MultiResolutionImageWriter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiResolutionImageWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MultiResolutionImageWriter, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _multiresolutionimageinterface.new_MultiResolutionImageWriter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _multiresolutionimageinterface.delete_MultiResolutionImageWriter
    __del__ = lambda self: None

    def openFile(self, fileName: 'std::string const &') -> "int":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_openFile(self, fileName)

    def getOpenFile(self) -> "std::string const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getOpenFile(self)

    def writeImageInformation(self, sizeX: 'unsigned long long const &', sizeY: 'unsigned long long const &') -> "int":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_writeImageInformation(self, sizeX, sizeY)

    def writeBaseImagePart(self, data: 'void *') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_writeBaseImagePart(self, data)

    def writeBaseImagePartToLocation(self, data: 'void *', x: 'unsigned long long const &', y: 'unsigned long long const &') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_writeBaseImagePartToLocation(self, data, x, y)

    def writeImageToFile(self, img: 'MultiResolutionImage', fileName: 'std::string const &') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_writeImageToFile(self, img, fileName)

    def finishImage(self) -> "int":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_finishImage(self)

    def setCompression(self, codec: 'pathology::Compression const &') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setCompression(self, codec)

    def getCompression(self) -> "pathology::Compression const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getCompression(self)

    def setInterpolation(self, interpolation: 'pathology::Interpolation const &') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setInterpolation(self, interpolation)

    def getInterpolation(self) -> "pathology::Interpolation const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getInterpolation(self)

    def setDataType(self, dType: 'pathology::DataType const &') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setDataType(self, dType)

    def getDataType(self) -> "pathology::DataType const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getDataType(self)

    def setColorType(self, cType: 'pathology::ColorType const &') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setColorType(self, cType)

    def setNumberOfIndexedColors(self, numberOfIndexedColors: 'unsigned int const') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setNumberOfIndexedColors(self, numberOfIndexedColors)

    def getNumberOfIndexedColors(self) -> "unsigned int":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getNumberOfIndexedColors(self)

    def getColorType(self) -> "pathology::ColorType const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getColorType(self)

    def setTileSize(self, tileSize: 'unsigned int const &') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setTileSize(self, tileSize)

    def setSpacing(self, spacing: 'vector_double') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setSpacing(self, spacing)

    def getTileSize(self) -> "unsigned int const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getTileSize(self)

    def getOverrideSpacing(self) -> "std::vector< double,std::allocator< double > > const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getOverrideSpacing(self)

    def setOverrideSpacing(self, spacing: 'vector_double') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setOverrideSpacing(self, spacing)

    def setJPEGQuality(self, quality: 'float const &') -> "int const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setJPEGQuality(self, quality)

    def getJPEGQuality(self) -> "float const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getJPEGQuality(self)

    def setProgressMonitor(self, monitor: 'ProgressMonitor *') -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setProgressMonitor(self, monitor)
MultiResolutionImageWriter_swigregister = _multiresolutionimageinterface.MultiResolutionImageWriter_swigregister
MultiResolutionImageWriter_swigregister(MultiResolutionImageWriter)

# This file is compatible with both classic and new-style classes.
